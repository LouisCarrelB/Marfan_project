---
title: " Alignement "
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: hide
    highlight: espresso
    theme: yeti
    toc: yes
    toc_depth: 3
    toc_float: yes
---

```{r PARAM, include=FALSE}


SEUIL = -6.5

scape_gap = TRUE 

INTERVALLE = c(1700,1750)

mutation_pathogene = "non" #patho, div or non 

treshold = 1




```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

```{r library,  message=FALSE,fig.width=10,fig.height=6,warning=FALSE}

library(ggplot2)
library(knitr)
library(rmarkdown)
library(stringr)
library(tidyverse)
library(reshape2)
library(heatmaply)
library(Biostrings)
library(openxlsx)
library(readxl)
library(gridExtra)
library(patchwork)
library(ggnewscale)
library(RColorBrewer)
library(msa)
library(cowplot)
library(seqLogo)
library(immunarch)
library(gglogo)
library(cluster)
 theme_set( theme_classic())



```

```{r Datas,  warning=FALSE, message=FALSE}

cat("Threshold for EvolCombi:", SEUIL, "| Truncate sequence for gaps in the WT?:", scape_gap)
cat("type of mutation studied here :", mutation_pathogene)



#PATH ##########################################################################

path_prot = "./FBN1/P35555/"               #chemin relatif  
path_thoraxe = "./FBN1/thoraxe/"
path_phylosof = paste0(path_thoraxe,"phylosofs/")
path_msa = paste0(path_thoraxe,"msa/")

# DATA #########################################################################
Conservation = read.table(paste0(path_prot,"P35555_conservation.txt"))
EvolCombi = read.table(paste0(path_prot,"P35555_normPred_evolCombi.txt"))
EvolEpi = read.table(paste0(path_prot,"P35555_normPred_evolEpi.txt"))
EvolInd = read.table(paste0(path_prot,"P35555_normPred_evolInd.txt"))

Ases_table = read.csv(paste0(path_thoraxe,"ases_table.csv"))
Path_table = read.csv(paste0(path_thoraxe,"path_table.csv"))
s_exon = read.csv(paste0(path_thoraxe,"s_exon_table.csv"))
transcripts_pir = readLines(paste0(path_phylosof,"transcripts.pir"))


#######prot #####################################################################
fichier_fasta <- paste0(path_prot,"P35555.FASTA")
lines <- readLines(fichier_fasta)

sequence_dict <- list()

current_seq_name <- ""
current_seq <- character()
 
for (line in lines) {
  if (startsWith(line, ">")) {
    if (current_seq_name != "") {
      sequence_dict[[current_seq_name]] <- paste(current_seq, collapse = "")
    }
    current_seq_name <- substr(line, 2, nchar(line))
    current_seq <- character()  
  } else {
    current_seq <- c(current_seq, line)
  }
}

# Enregistrez la dernière séquence
if (current_seq_name != "") {
  sequence_dict[[current_seq_name]] <- paste(current_seq, collapse = "")
}

P35555 = sequence_dict$P35555


file_path <- "./FBN1/FBN1stru.xls"

sheet_names <- excel_sheets(file_path)

# Charger les données de chaque feuille dans une liste
FBN1_structure <- lapply(sheet_names, function(sheet) {
  read_excel(file_path, sheet = sheet)
})
mutation_tb5 = FBN1_structure[[2]]
colnames(mutation_tb5) <- c("Mutation", "Phénotype")
mutation_tb5 <- mutation_tb5 %>% filter(!is.na(Mutation) & !grepl("Variation", Mutation))
mutation_tb5 <- mutation_tb5 %>% mutate(
  AA_de_base = str_extract(Mutation, "[A-Z][a-z]*"),
  Position = str_extract(Mutation, "\\d+"),
  AA_substitue = str_extract(Mutation, "[A-Z][a-z]*$")
)

mutation_mfs = FBN1_structure[[3]]
colnames(mutation_mfs) <- c("1","2","3","4","Mutation","Phénotype" )
mutation_mfs<- mutation_mfs %>% filter(!is.na(Mutation) & !grepl("Variation", Mutation))
mutation_mfs <- mutation_mfs %>% mutate(
  AA_de_base = str_extract(Mutation, "[A-Z][a-z]*"),
  Position = str_extract(Mutation, "\\d+"),
  AA_substitue = str_extract(Mutation, "[A-Z][a-z]*$")
)


mutation_probable = FBN1_structure[[6]]
colnames(mutation_probable) <- c("Mutation","c.")
mutation_probable<- mutation_probable %>% filter(!is.na(Mutation) & !grepl("Variation", Mutation))
mutation_probable <- mutation_probable %>% mutate(
  AA_de_base = str_extract(Mutation, "[A-Z][a-z]*"),
  Position = str_extract(Mutation, "\\d+"),
  AA_substitue = str_extract(Mutation, "[A-Z][a-z]*$")
)
mutation_probable$classe <- 0  
# Trouve les indices où chaque classe apparaît dans la colonne "Mutation"
classes <- unique(mutation_probable$Mutation[grep("^Classe", mutation_probable$Mutation)])
for (classe in classes) {
  classe_indices <- which(mutation_probable$Mutation == classe)
  
  # Attribue la valeur correspondante à la nouvelle colonne pour les lignes en dessous de chaque classe
  if (length(classe_indices) > 0) {
    mutation_probable$classe[(classe_indices[1] + 1):nrow(mutation_probable)] <- (gsub("^Classe ", "", classe))
  }
}
mutation_probable <- mutation_probable %>% filter(!grepl("^Classe", Mutation))


mutation_non_sens = FBN1_structure[[4]]
mutation_non_sens<- mutation_non_sens[,c("p.","Clinique","Néomutation?","Cardio","Ophtalmo","SK","Pneumothorax","cutané","neuro","Sévère ou jeune")]
mutation_non_sens <- mutation_non_sens %>%
  mutate(
    AA_de_base = str_extract(p., "[A-Z][a-z]*"),
    Position = as.integer(str_extract(p., "\\d+")), # Convertir la position en entier
    AA_substitue = str_extract(p., "[A-Z][a-z]*$"),
    Clinique = str_extract(Clinique, "^[A-Za-z]+"),

    

  )

correspondance <- data.frame(
  AA_3_lettres = c("Ala", "Arg", "Asn", "Asp", "Cys", "Gln", "Glu", "Gly", "His", "Ile", "Leu", "Lys", "Met", "Phe", "Pro", "Ser", "Thr", "Trp", "Tyr", "Val","A", "R", "N", "D", "C", "Q", "E", "G", "H", "I", "L", "K", "M", "F", "P", "S", "T", "W", "Y", "V"),
  AA_1_lettre = c("a", "r", "n", "d", "c", "q", "e", "g", "h", "i", "l", "k", "m", "f", "p", "s", "t", "w", "y", "v","a", "r", "n", "d", "c", "q", "e", "g", "h", "i", "l", "k", "m", "f", "p", "s", "t", "w", "y", "v")
)



# Joindre la table de correspondance pour convertir les notations en trois lettres en une lettre
mutation_tb5 <- mutation_tb5 %>%
  left_join(correspondance, by = c("AA_de_base" = "AA_3_lettres")) %>%
  left_join(correspondance, by = c("AA_substitue" = "AA_3_lettres"))


mutation_mfs <- mutation_mfs %>%
  left_join(correspondance, by = c("AA_de_base" = "AA_3_lettres")) %>%
  left_join(correspondance, by = c("AA_substitue" = "AA_3_lettres"))

mutation_probable <- mutation_probable %>%
  left_join(correspondance, by = c("AA_de_base" = "AA_3_lettres")) %>%
  left_join(correspondance, by = c("AA_substitue" = "AA_3_lettres")) 

mutation_non_sens = mutation_non_sens %>%
  left_join(correspondance, by = c("AA_de_base" = "AA_3_lettres")) %>%
  left_join(correspondance, by = c("AA_substitue" = "AA_3_lettres")) 


# Sélectionner uniquement les colonnes nécessaires et renommer
mutation_tb5 <- mutation_tb5 %>% 
  select(Mutation, Phénotype, AA_de_base = AA_1_lettre.x, Position, AA_substitue = AA_1_lettre.y) %>% select(AA_de_base, Position, AA_substitue)

mutation_mfs <- mutation_mfs %>% 
  select(Mutation, Phénotype, AA_de_base = AA_1_lettre.x, Position, AA_substitue = AA_1_lettre.y) %>% select(AA_de_base, Position, AA_substitue)

mutation_probable <- mutation_probable %>% 
  select(Mutation, AA_de_base = AA_1_lettre.x, Position, AA_substitue = AA_1_lettre.y, classe) %>% select(AA_de_base, Position, AA_substitue,classe)

mutation_non_sens = mutation_non_sens %>% select(Clinique, AA_de_base = AA_1_lettre.x, Position, AA_substitue = AA_1_lettre.y,"Néomutation?","Cardio","Ophtalmo","SK","Pneumothorax","cutané","neuro","Sévère ou jeune") %>% select(AA_de_base, Position, AA_substitue,Clinique,"Néomutation?","Cardio","Ophtalmo","SK","Pneumothorax","cutané","neuro","Sévère ou jeune") %>% 
  filter(!is.na(AA_de_base))

                                                                                                                                                         




mutation_tb5 = data.frame(mutation_tb5)
mutation_mfs = data.frame(mutation_mfs)
mutation_probable = data.frame(mutation_probable)
mutation_non_sens = data.frame(mutation_non_sens)

mutation <- rbind(mutation_tb5, mutation_mfs)




########## s_exons/msa ##########################################################
fasta_files <- list.files(path_msa, pattern = ".fasta$", full.names = TRUE)

fasta_data <- data.frame(Nom_Fichier = character(0), Sequence = character(0), stringsAsFactors = FALSE)

for (fasta_file in fasta_files) {
  fasta_content <- readLines(fasta_file)
  title <- fasta_content[1]
  sequence <- paste(fasta_content, collapse = "")  # Combinez toutes les lignes de séquence

  fasta_data <- rbind(fasta_data, data.frame(Nom_Fichier = basename(fasta_file), Sequence = sequence, stringsAsFactors = FALSE))
}

#En temps normal essayer de le généraliser en le trouvant par exepression régulière dans le .PIR 
transcriptID_WT = "ENST00000316623"

cat("Here WT sequence transcript is computed by MEGA software | Transcript : ", transcriptID_WT ) 


row_index <- which(Path_table$TranscriptIDCluster == transcriptID_WT)

if (length(row_index) == 0) {
  break 
} else {
  path_WT <- Path_table$Path[row_index]

}


 # Convertir le chemin path_WT en vecteur d'éléments
path_elements <- unlist(strsplit(path_WT, "/"))

# Créer un vecteur de noms de fichiers correspondant à chaque élément du chemin
file_names <- paste0("msa_s_exon_", path_elements, ".fasta")

# Subset fasta_data en fonction de l'ordre des fichiers
subset_fasta_data <- fasta_data[fasta_data$Nom_Fichier %in% file_names, ]

# Diviser la colonne "Sequence" en plusieurs colonnes
seq_list <- strsplit(subset_fasta_data$Sequence, ">")

for (i in 1:length(seq_list)) {
  seqs <- seq_list[[i]]
  for (j in 1:length(seqs)) {
    seqs[j] <- gsub(".*([0-9])", "", seqs[j])
  }
  seq_list[[i]] <- seqs
}

# Créer une nouvelle liste pour stocker les séquences exon par exon
exon_sequences_list <- list()

# Parcourir seq_list et diviser en séquences exon par exon
for (i in 1:length(seq_list)) {
  seqs <- seq_list[[i]]
  exon_sequences_list[[i]] <- unlist(strsplit(seqs, ">"))
}

# Trouver la longueur maximale des listes de séquences exon par exon
max_length <- max(sapply(exon_sequences_list, length))

# Assurer que toutes les listes de séquences ont la même longueur
for (i in 1:length(exon_sequences_list)) {
  if (length(exon_sequences_list[[i]]) < max_length) {
    diff_length <- max_length - length(exon_sequences_list[[i]])
    exon_sequences_list[[i]] <- c(exon_sequences_list[[i]], rep(NA, diff_length))
  }
}

# Créer un nouveau dataframe avec les séquences exon par exon
new_fasta_data <- data.frame(Nom_Fichier = subset_fasta_data$Nom_Fichier)
for (i in 1:max_length) {
  column_name <- paste("Exon", i, sep = "_")
  new_fasta_data[[column_name]] <- sapply(exon_sequences_list, function(x) x[i])
}



# Obtenez l'ordre des noms de fichiers dans le dataframe actuel
order_in_fasta_data <- match(file_names, new_fasta_data$Nom_Fichier)

# Réorganisez les lignes du dataframe en fonction de l'ordre obtenu
new_fasta_data <- new_fasta_data[order_in_fasta_data, ]

# Réinitialisez les indices des lignes du dataframe pour qu'ils soient consécutifs
row.names(new_fasta_data) <- NULL


# Supprimer start and stop
new_fasta_data <- new_fasta_data[-c(1, nrow(new_fasta_data)), ]

# Supprimer la première colonne NomFichier
new_fasta_data <- new_fasta_data[, -1]

new_fasta_data <- as.data.frame(lapply(new_fasta_data, tolower))

if (scape_gap) {

# Fonction pour aligner les séquences en supprimant les acides aminés correspondants aux gaps dans la première séquence
aligner_sequences <- function(seq, reference) {
  seq_alignee <- ""
  for (i in 1:nchar(reference)) {
    if (substr(reference, i, i) != "-") {
      seq_alignee <- paste0(seq_alignee, substr(seq, 1, 1))
      seq <- substr(seq, 2, nchar(seq))
    }
    else {
      seq <- substr(seq, 2, nchar(seq))
    }
  }
  return(seq_alignee)
}

for (MSA in rownames(new_fasta_data)) {
  reference <- new_fasta_data[MSA, "Exon_1"]
  sequences_alignees <- lapply(new_fasta_data[MSA, ], aligner_sequences, reference = reference)
  new_fasta_data[MSA, ] <- sequences_alignees
}

new_fasta_data <- new_fasta_data %>%
  mutate_all(~ifelse(substr(., 1, 1) == "N", NA, .))

}



# Créez une matrice vide pour stocker les résultats
result_matrix <- matrix(0, nrow = 0, ncol = 26)

# Parcourez chaque ligne de new_fasta_data
for (i in 1:nrow(new_fasta_data)) {
  sequences <- new_fasta_data[i,]
  position_counts <- matrix(0, nrow = nchar(sequences[[1]]), ncol = 26)
  
  # Comptez les acides aminés à chaque position
  for (j in 1:nchar(sequences[[1]])) {
    position <- substr(sequences, j, j)
    counts <- table(position)
    position_counts[j, ] <- counts[letters]
  }
  
  # Ajoutez les résultats à la matrice résultante
  result_matrix <- rbind(result_matrix, position_counts)
}

# Réinitialisez les noms de colonnes et de lignes
colnames(result_matrix) <- letters
rownames(result_matrix) <- 1:nrow(result_matrix)


# Convertir la matrice en un data frame long
data_longMSA <- as.data.frame(result_matrix)

# Ajouter une colonne pour la position
data_longMSA <- data_longMSA %>%
  mutate(Position = row_number())

# Renommer les colonnes en fonction des acides aminés
data_longMSA <- data_longMSA %>%
  pivot_longer(cols = -Position, names_to = "Acide_aminé", values_to = "Compte")

# Remplacer les NA par des 0
data_longMSA[is.na(data_longMSA$Compte), "Compte"] <- 0

names(data_longMSA) = c("ColumnNames","RowNames","Value")



##### Pour les séquences genomiques #########

# Supprimer les colonnes inutiles
FBN1_structure_cleaned <- FBN1_structure[[1]] %>%
  select(`n°aa`, aa, Structure)

# Fusionner avec la table de correspondance
FBN1_structure_cleaned <- merge(FBN1_structure_cleaned, correspondance, by.x = "aa", by.y = "AA_3_lettres", all.x = TRUE)

# Trier par le numéro d'acide aminé
FBN1_structure_cleaned <- FBN1_structure_cleaned[order(FBN1_structure_cleaned$`n°aa`), ]

# Créer la nouvelle table
Table_seq <- FBN1_structure_cleaned %>%
  group_by(`Structure`) %>%
  summarize(
    Sequence_AA = paste(AA_1_lettre[order(`n°aa`)], collapse = ""),
    Debut_Fin = paste(min(`n°aa`), max(`n°aa`), sep = ";"),
    Longueur = nchar(Sequence_AA)
  )

FBN1_structure_cleaned_mutated <- merge(FBN1_structure_cleaned, mutation_non_sens, by.x = "n°aa", by.y = "Position", all.x = TRUE)
FBN1_structure_cleaned_mutated$AA_1_lettre <- ifelse(!is.na(FBN1_structure_cleaned_mutated$AA_substitue), FBN1_structure_cleaned_mutated$AA_substitue, FBN1_structure_cleaned_mutated$AA_1_lettre)

Table_seq_mutated <- FBN1_structure_cleaned_mutated %>%
  group_by(`Structure`) %>%
  summarize(
    Sequence_AA = paste(AA_1_lettre[order(`n°aa`)], collapse = ""),
    Debut_Fin = paste(min(`n°aa`), max(`n°aa`), sep = ";"),
    Longueur = nchar(Sequence_AA)
  )



```

\

#### R

This feature allows you to display the version of the programming language used (configurable).

```{r runInfo_r,  message=FALSE}
# print( sessionInfo());

```

### 1/ Alignments and threshold {.tabset .tabset-fade}

Here, in order to visualize certain amino acids that are more deleterious than others (calculated using GEMME), we set a threshold (configurable), below which amino acids are considered non-deleterious (gray), and above which they are considered deleterious (red). Additionally, dark gray represents the wild-type (WT) amino acids, and in blue, the WT amino acids that have pathogenic deletions according to information from Bichat Hospital. In green, the amino acids are marked as pathogenic if they are present in the sequence (per Bichat Hospital's data). Finally, in purple, the color indicates the presence of both green and red, signifying amino acids that are both deleterious (according to GEMME) and pathogenic (per Bichat Hospital's data).

The top histogram allows us to visualize the average impact score (deleterious or non-deleterious) by position.

The lower histogram, on the other hand, displays the evolutionary conservation by position.

The second tab allows for zooming in on a selected sequence (configurable).

#### General view of the protein

```{r heatmaps,  message=FALSE,fig.width=10,fig.height=10,warning=FALSE}

### Hist ####################################################################

EvolCombi_matrix <- as.matrix(EvolCombi)

for (col in 1:ncol(EvolCombi_matrix)) {
  col_mean <- mean(EvolCombi_matrix[, col], na.rm = TRUE)  
  EvolCombi_matrix[is.na(EvolCombi_matrix[, col]), col] <- col_mean
}

col_means_Combi <- colMeans(EvolCombi_matrix)


mean_data <- data.frame(Index = 1:length(col_means_Combi), Mean = col_means_Combi)

histogram <- ggplot(mean_data, aes(x = Index, y = Mean)) +
  geom_bar(stat = "identity", fill = "blue") +
  labs(title = "Histogramme des Moyennes EvolCombi par colonne", x = "Index a.a", y = "Moyenne EvolCombi") +
    geom_hline(yintercept = SEUIL, color = "red", linetype = "dashed", size = 1) +
  annotate("text", x = 1, y = SEUIL + 0.2, label = paste("SEUIL =", SEUIL), color = "red")

###############################################################################
data <- EvolCombi

matrice1 <- FBN1_structure[[1]]
indices_lignes_non_na <- !is.na(matrice1$`Régions particulières`)
noms_de_lignes <- matrice1$`Régions particulières`[indices_lignes_non_na]
numeros_de_lignes <- matrice1$`n°aa`[indices_lignes_non_na]
régions <- data.frame(NomDeLigne = noms_de_lignes, NumeroDeLigne = numeros_de_lignes)

seuil <- SEUIL
binary_matrix <- apply(EvolCombi, MARGIN = c(1, 2), FUN = function(x) ifelse(x > seuil, 0, 1))

rownames(binary_matrix) <- rownames(data)



data_df <- as.data.frame(binary_matrix)
data_df$RowNames <- rownames(data_df)  

data_long <- reshape2::melt(data_df, id.vars = "RowNames")
colnames(data_long) <- c("RowNames", "ColumnNames", "Value")
data_long$ColumnNames <- as.numeric(data_long$ColumnNames)


regions_indices <- which(!is.na(matrice1$`Régions particulières`))



if (mutation_pathogene == "patho"){
for (i in 1:nrow(mutation)) {
  # Récupérer la position, la lettre de base et la lettre substituée
  position <- mutation$Position[i]
  lettre_base <- mutation$AA_de_base[i]
  lettre_substituee <- mutation$AA_substitue[i]
  
  # Trouver l'indice correspondant dans data_long
  index <- which(data_long$ColumnNames == position)
  
    
   if (!is.na(lettre_substituee)) {
    if (data_long$Value[index[data_long$RowNames[index] == lettre_substituee]] == 1) {
      data_long$Value[index[data_long$RowNames[index] == lettre_substituee]] <- 4} else {
        data_long$Value[index[data_long$RowNames[index] == lettre_substituee]] <- 2}
   }  else {data_long$Value[index[data_long$RowNames[index] == lettre_base]] <- 3
    }
}} 
if (mutation_pathogene == "div") {
for (i in 1:nrow(mutation_probable)) {
  # Récupérer la position, la lettre de base et la lettre substituée
  position <- mutation_probable$Position[i]
  lettre_base <- mutation_probable$AA_de_base[i]
  lettre_substituee <- mutation_probable$AA_substitue[i]
  
  # Trouver l'indice correspondant dans data_long
  index <- which(data_long$ColumnNames == position)
  
    
   if (!is.na(lettre_substituee)) {
    if (data_long$Value[index[data_long$RowNames[index] == lettre_substituee]] == 1) {
      data_long$Value[index[data_long$RowNames[index] == lettre_substituee]] <- 4} else {
        data_long$Value[index[data_long$RowNames[index] == lettre_substituee]] <- 2}
   }  else {data_long$Value[index[data_long$RowNames[index] == lettre_base]] <- 3
    }
}}


if (mutation_pathogene == "non") {
  for (i in 1:nrow(mutation_non_sens)) {
  # Récupérer la position, la lettre de base et la lettre substituée
  position <- mutation_non_sens$Position[i]
  lettre_base <- mutation_non_sens$AA_de_base[i]
  lettre_substituee <- mutation_non_sens$AA_substitue[i]
  
  # Trouver l'indice correspondant dans data_long
  index <- which(data_long$ColumnNames == position)
  
    
   if (!is.na(lettre_substituee)) {
    if (data_long$Value[index[data_long$RowNames[index] == lettre_substituee]] == 1) {
      data_long$Value[index[data_long$RowNames[index] == lettre_substituee]] <- 4} else {
        data_long$Value[index[data_long$RowNames[index] == lettre_substituee]] <- 2}
   }  else {data_long$Value[index[data_long$RowNames[index] == lettre_base]] <- 3
    }
  
}}
  


my_palette <- colorRampPalette(c("grey", "red", "green", "blue", "purple"))(n = 5)

legend_labels <- c("Non_Impactful", "Impactful", "Pathogenic", "Patogenic Deletion", "Pathogenic and Impactful","WT")

a_plot = ggplot(data_long, aes(x = ColumnNames, y = RowNames, fill = as.factor(Value))) +
  geom_tile() +
  scale_fill_manual(values = my_palette, labels = legend_labels)+
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1) 
  ) +
  labs(x = "Index", y = "Acide Aminés", fill = "Valeur") +
  guides(fill = guide_legend(title = "Valeur")) +
  scale_x_discrete()  


trace_data <- as.data.frame(t(Conservation["trace",]))
trace_data$Index <- colnames(Conservation)
colnames(trace_data) <- c("Value", "Index")
df_trace <- trace_data
# Transformation des valeurs dans la colonne "Index" en numériques
trace_data$Index <- as.numeric(gsub("X", "", trace_data$Index))


b_plot <- ggplot(trace_data, aes(x = Index, y = Value)) +
  geom_bar(data = trace_data %>% filter(Index %in% regions_indices), aes(x = Index, y = Value, fill = "Région particulière"), stat = "identity") +
  geom_bar(data = trace_data %>% filter(!Index %in% regions_indices), aes(x = Index, y = Value, fill = "Autre région"), stat = "identity") +
  labs(title = "Trace par position sur la protéine", x = "Index", y = "Trace") +
  scale_fill_manual(values = c("Région particulière" = "green"), labels = "Région particulière", name = "")


combined_plot <- histogram + a_plot + b_plot + plot_layout(nrow = 3, heights = c(1,3, 1))


print(combined_plot)


```

#### Sequences chosen

Here, any sequence can be easily zoomed in on request from the developer.

```{r Zoom,  message=FALSE,fig.width=10,fig.height=10,warning=FALSE}


intervalle = INTERVALLE

print(intervalle)

histogram <- histogram +
  xlim(intervalle)
a_plot <- a_plot +
  xlim(intervalle)
b_plot <- b_plot +
  xlim(intervalle)
combined_plot <- histogram + a_plot + b_plot + plot_layout(nrow = 3, heights = c(1, 3, 1))


print(combined_plot)


```

### 2/ Alignments {.tabset .tabset-fade}

Here, we disregard the threshold, and instead, we have a gradient of red indicating the GEMME score (the lower the value, the more deleterious the amino acid), and another color gradient in blue representing the same values but for pathogenic amino acids (according to Bichat Hospital's data). In yellow, we highlight the WT amino acids that are pathogenic in case of deletion, and in gray, the non-pathogenic WT amino acids.

The black dots (MSA) indicate the multiple sequence alignments found for each exon (for the human WT sequence). Each column can have a maximum of 10 different points, as these alignments are performed with 10 different species.

The two histograms are the same as in part 1.

#### General view of the protein

```{r heatmaps_2,  message=FALSE,fig.width=10,fig.height=10,warning=FALSE}

### Hist ####################################################################

EvolCombi_matrix <- as.matrix(EvolCombi)

for (col in 1:ncol(EvolCombi_matrix)) {
  col_mean <- mean(EvolCombi_matrix[, col], na.rm = TRUE)  
  EvolCombi_matrix[is.na(EvolCombi_matrix[, col]), col] <- col_mean
}

col_means_Combi <- colMeans(EvolCombi_matrix)


mean_data <- data.frame(Index = 1:length(col_means_Combi), Mean = col_means_Combi)

histogram <- ggplot(mean_data, aes(x = Index, y = Mean)) +
  geom_bar(stat = "identity", fill = "blue") +
  labs(title = "Histogramme des Moyennes EvolCombi par colonne", x = "Index a.a", y = "Moyenne EvolCombi") 

###############################################################################
data <- EvolCombi
data_df <- as.data.frame(data)
data_df$RowNames <- rownames(data_df)  
data_long_ori <- reshape2::melt(data_df, id.vars = "RowNames")
colnames(data_long_ori) <- c("RowNames", "ColumnNames", "Value")
data_long_ori$ColumnNames <- as.numeric(data_long_ori$ColumnNames)
data_long_ori <- data_long_ori %>%
  mutate(Key = 0)


### Région particulière 
matrice1 <- FBN1_structure[[1]]
indices_lignes_non_na <- !is.na(matrice1$`Régions particulières`)
noms_de_lignes <- matrice1$`Régions particulières`[indices_lignes_non_na]
numeros_de_lignes <- matrice1$`n°aa`[indices_lignes_non_na]
régions <- data.frame(NomDeLigne = noms_de_lignes, NumeroDeLigne = numeros_de_lignes)
regions_indices <- which(!is.na(matrice1$`Régions particulières`))


if (mutation_pathogene == "patho"){
for (i in 1:nrow(mutation)) {
  # Récupérer la position, la lettre de base et la lettre substituée
  position <- mutation$Position[i]
  lettre_base <- mutation$AA_de_base[i]
  lettre_substituee <- mutation$AA_substitue[i]
  
  # Trouver l'indice correspondant dans data_long_ori
  index <- which(data_long_ori$ColumnNames == position)
  
   if (!is.na(lettre_substituee)) {
      data_long_ori$Key[index[data_long_ori$RowNames[index] == lettre_substituee]] <- 1
   }  else {data_long_ori$Key[index[data_long_ori$RowNames[index] == lettre_base]] <- 2
   } } } 



if (mutation_pathogene == "div") {
for (i in 1:nrow(mutation_probable)) {
  # Récupérer la position, la lettre de base et la lettre substituée
  position <- mutation_probable$Position[i]
  lettre_base <- mutation_probable$AA_de_base[i]
  lettre_substituee <- mutation_probable$AA_substitue[i]
  
  # Trouver l'indice correspondant dans data_long_ori
  index <- which(data_long_ori$ColumnNames == position)
  
   if (!is.na(lettre_substituee)) {
      data_long_ori$Key[index[data_long_ori$RowNames[index] == lettre_substituee]] <- 1
   }  else {data_long_ori$Key[index[data_long_ori$RowNames[index] == lettre_base]] <- 2
   } }}



if (mutation_pathogene == "non") {
for (i in 1:nrow(mutation_non_sens)) {
  # Récupérer la position, la lettre de base et la lettre substituée
  position <- mutation_non_sens$Position[i]
  lettre_base <- mutation_non_sens$AA_de_base[i]
  lettre_substituee <- mutation_non_sens$AA_substitue[i]
  
  # Trouver l'indice correspondant dans data_long_ori
  index <- which(data_long_ori$ColumnNames == position)
  
   if (!is.na(lettre_substituee)) {
      data_long_ori$Key[index[data_long_ori$RowNames[index] == lettre_substituee]] <- 1
   }  else {data_long_ori$Key[index[data_long_ori$RowNames[index] == lettre_base]] <- 2
   } }}



data_long <- data_long_ori %>%
  mutate(Key = ifelse(is.na(Value) & Key != 2, 3, Key))



data_long0 <- data_long %>%
  filter(Key == 0) %>%
  select(-Key)

##Patch pour bug des heatmaps 
data_long0 <- data_long %>%
  mutate(Value = ifelse(Key == 1, Value - 20, Value))
#######
data_long1 <- data_long %>%
  filter(Key == 1) %>%
  select(-Key)

data_long2 <- data_long %>%
  filter(Key == 2) %>%
  select(-Key)

data_long3 <- data_long %>%
  filter(Key == 3) %>%
  select(-Key)



data_long4 <- data_longMSA %>%
  filter(Value != 0)  %>% mutate(Value = NA)

data_long1$Value <- as.numeric(data_long1$Value)
write.csv(data_long1, file = "mutations.csv", row.names = TRUE)



colors <- c("#4B0000", "#F08080", "#008000", "#FFFFFF")


a_plot <- ggplot(data_long0, aes(ColumnNames, RowNames)) +
  labs(x = "Index", y = "Acide Aminés") +
  geom_tile(aes(fill = Value)) +
scale_fill_gradientn(colors = colors, values = scales::rescale(c(-20, -6, 0, 10)), name = "selection pressure") +
  new_scale_fill() +
 #  geom_tile(data = data_long1, aes(x = ColumnNames, y = RowNames, fill = Value)) +
 # scale_fill_gradientn(colors = rev(brewer.pal(9, "Blues")), name = "Pathogenic")+
 #  guides(fill = guide_legend(title = "Pathogenic")) +
 #  new_scale_fill() +
  geom_tile(data = data_long2, aes(fill = "WT deleted is pathogenic")) +
  scale_fill_manual(values = "yellow", name = "Deletion") +
  new_scale_fill() +
  geom_tile(data = data_long3, aes(fill = "WT")) +
  scale_fill_manual(values = "gray", name = "WT") +
  new_scale_fill() +
  geom_point(data = data_long4, aes(x = ColumnNames, y = RowNames), shape = 19, size = 0.4, color = "black", name = "MSA") +
  geom_tile(data = data_long4, aes(fill = "MSA")) +
  scale_fill_manual(values = "transparent", name = "MSA") 

  

trace_data <- as.data.frame(t(Conservation["trace",]))
trace_data$Index <- colnames(Conservation)
colnames(trace_data) <- c("Value", "Index")
df_trace <- trace_data



###### Hist régions particulière
# Transformation des valeurs dans la colonne "Index" en numériques
trace_data$Index <- as.numeric(gsub("X", "", trace_data$Index))


b_plot <- ggplot(trace_data, aes(x = Index, y = Value)) +
  geom_bar(data = trace_data %>% filter(Index %in% regions_indices), aes(x = Index, y = Value, fill = "Région particulière"), stat = "identity") +
  geom_bar(data = trace_data %>% filter(!Index %in% regions_indices), aes(x = Index, y = Value, fill = "Autre région"), stat = "identity") +
  labs(title = "Trace par position sur la protéine", x = "Index", y = "Trace") +
  scale_fill_manual(values = c("Région particulière" = "green"), labels = "Région particulière", name = "")

combined_plot <- histogram + a_plot + b_plot + plot_layout(nrow = 3, heights = c(1,3,1))


print(combined_plot)




```

#### Domaine TB5

```{r Zoom_3,  message=FALSE,fig.width=10,fig.height=10,warning=FALSE}


intervalle = c(1685,1770)

print(intervalle)

histogram <- histogram +
  xlim(intervalle)
a_plot <- a_plot +
  xlim(intervalle)
b_plot <- b_plot +
  xlim(intervalle)
combined_plot <- histogram + a_plot + b_plot + plot_layout(nrow = 3, heights = c(1, 3, 1))


print(combined_plot)



```

#### Région néonatale

```{r Zoom_2,  message=FALSE,fig.width=10,fig.height=10,warning=FALSE}


intervalle = c(930,1380)

print(intervalle)

histogram <- histogram +
  xlim(intervalle)
a_plot <- a_plot +
  xlim(intervalle)
b_plot <- b_plot +
  xlim(intervalle)
combined_plot <- histogram + a_plot + b_plot + plot_layout(nrow = 3, heights = c(1, 3, 1))


print(combined_plot)


cat("mutation sur 1070") 

intervalle = c(1060,1080)

print(intervalle)

histogram <- histogram +
  xlim(intervalle)
a_plot <- a_plot +
  xlim(intervalle)
b_plot <- b_plot +
  xlim(intervalle)
combined_plot <- histogram + a_plot + b_plot + plot_layout(nrow = 3, heights = c(1, 3, 1))


print(combined_plot)


cat("mutation sur 1748") 
intervalle = c(1740,1755)

print(intervalle)

histogram <- histogram +
  xlim(intervalle)
a_plot <- a_plot +
  xlim(intervalle)
b_plot <- b_plot +
  xlim(intervalle)
combined_plot <- histogram + a_plot + b_plot + plot_layout(nrow = 3, heights = c(1, 3, 1))


print(combined_plot)



```

#### Table of pathogenis mutations

```{r Table,  message=FALSE,fig.width=10,fig.height=10,warning=FALSE}



cat("Ici se trouve la table ou les mutations pathogènes sont enregistré (variance de bleus) afin de vérifier les erreurs du plot")
print(kable(data_long1))
```

## Scatter plot mutations

```{r mutations,  warning=FALSE, message=FALSE,fig.width=15,fig.height=15}


colnames(mean_data)[colnames(mean_data) == "Index"] <- "Position"
if (mutation_pathogene == "patho") {merged_data <- merge(mutation, mean_data, by = "Position")
mutations_mean_gemme <- merged_data[!is.na(merged_data$AA_substitue), c("AA_substitue", "Position", "Mean")]} 
if (mutation_pathogene == "div") {merged_data <- merge(mutation_probable, mean_data, by = "Position")
mutations_mean_gemme <- merged_data[!is.na(merged_data$AA_substitue), c("AA_substitue", "Position", "Mean","classe")]}
if (mutation_pathogene == "non") {merged_data <- merge(mutation_non_sens, mean_data, by = "Position")
mutations_mean_gemme <- merged_data[!is.na(merged_data$AA_substitue), c("AA_substitue", "Position", "Mean","Clinique","Néomutation.","Cardio","Ophtalmo","Pneumothorax","cutané","neuro","Sévère.ou.jeune")]}


melted_matrix <- rownames_to_column(EvolCombi, var = "AA_substitue")
melted_matrix <- melt(melted_matrix, id.vars = c("AA_substitue"), value.name = "EvolCombi") %>%
  mutate(Position = as.numeric(gsub("V", "", variable))) %>%
  select(AA_substitue, Position, EvolCombi)
merged_data_final <- merge(mutations_mean_gemme, melted_matrix, by = c("Position", "AA_substitue"))
scatter_plot_final <- ggplot(merged_data_final, aes(x = Mean, y = EvolCombi)) +
  geom_point()   +
  geom_text(aes(label = Position), hjust = 1, vjust = 1) +
  labs(x = "Mean GEMME", y = "GEMME Score for mutation") +
  ggtitle("Scatter Plot for Marfan mutations and GEMME score") + 
  coord_fixed(ratio = 1) 

if (mutation_pathogene == "non") {
  # Liste des colonnes à exclure lors de la création des scatter plots
  exclude_cols <- c("Position", "AA_substitue", "Mean", "EvolCombi","Clinique","Néomutation.")
  merged_data_final[is.na(merged_data_final)] <- 0
  
  # Parcourir toutes les colonnes sauf celles à exclure
for (col in setdiff(names(merged_data_final), exclude_cols)) {



  # Création du scatter plot pour chaque colonne
  scatter_plot <- ggplot(merged_data_final, aes_string(x = "Mean", y = "EvolCombi", color = col)) +
    geom_point() +
    labs(x = "Mean GEMME", y = "GEMME Score for mutation") +
    ggtitle(paste("Scatter Plot for Marfan mutations and GEMME score (", col, ")", sep = "")) + 
    coord_fixed(ratio = 1)  + 
    theme(
      plot.subtitle = element_text(size = 40), 
      plot.caption = element_text(size = 40), 
      axis.title = element_text(size = 10)) 
  
  # Sauvegarde du scatter plot dans un fichier
  print(scatter_plot)
  ggsave(paste("Mutation_plot/", col, "_scatter_plot.png", sep = ""), plot = scatter_plot)
}
}


if (mutation_pathogene == "div") {
scatter_plot_final <- ggplot(merged_data_final, aes(x = Mean, y = EvolCombi, color = classe)) +
  geom_point() +
  labs(x = "Mean GEMME", y = "GEMME Score for mutation") +
  ggtitle("Scatter Plot for Marfan mutations and GEMME score") + 
  coord_fixed(ratio = 1)
}


print(scatter_plot_final)

  
# Calculer les moyennes par position
mean_by_position <- aggregate(EvolCombi ~ Position, melted_matrix, mean)

# Ajouter la colonne Mean à melted_matrix
melted_matrix <- merge(melted_matrix, mean_by_position, by = "Position", suffixes = c("", ".Mean"))

# Créez la colonne InMutationsMeanGemme en fonction de la présence dans mutations_mean_gemme
melted_matrix$InMutationsMeanGemme <- ifelse(
  melted_matrix$AA_substitue == mutations_mean_gemme$AA_substitue & melted_matrix$Position == mutations_mean_gemme$Position,
  "Pathogenic",
  "Not Pathogenic"
)

# Réglage des échelles égales sur l'axe x et y
scatter_plot_final <- ggplot(melted_matrix, aes(x = EvolCombi.Mean, y = EvolCombi, color = InMutationsMeanGemme)) +
  geom_point(alpha = 0.01, size = 2, color = "blue") +
  geom_point(data = merged_data_final, aes(x = Mean, y = EvolCombi), color = "red", size = 2) +
  labs(x = "Mean GEMME", y = "GEMME Score for mutation") +
  ggtitle("Scatter Plot for Marfan mutations and GEMME score") +
  coord_fixed(ratio = 1)  +
  geom_vline(xintercept = mean(range(melted_matrix$EvolCombi.Mean)), linetype = "dashed", color = "gray") 
# Afficher le scatter plot
print(scatter_plot_final)


# Assurez-vous que les colonnes sur lesquelles vous fusionnez sont du même type
merged_data$Position <- as.numeric(as.character(merged_data$Position))
merged_data$AA_substitue <- as.character(merged_data$AA_substitue)

melted_matrix$Position <- as.numeric(as.character(melted_matrix$Position))
melted_matrix$AA_substitue <- as.character(melted_matrix$AA_substitue)

# Fusion externe complète pour garder toutes les lignes des deux data frames
PCA_data_long <- merge(merged_data, melted_matrix, by = c("Position", "AA_substitue"), all = TRUE)
PCA_data_long <- subset(PCA_data_long, select = c("Position", "AA_substitue", "Ophtalmo", "SK", "Pneumothorax", "Cardio", "cutané", "neuro", "Sévère.ou.jeune", "EvolCombi"))
write.csv(PCA_data_long, "PCA_data_long.csv", row.names = FALSE)






```

## Clustering {.tabset .tabset-fade}

### PCA

```{r Signature,  warning=FALSE, message=FALSE,fig.width=15,fig.height=15}
mutation_faux_pheno <- mutation_non_sens %>%
  select(6:12)

mutation_faux_pheno_rows <- mutation_non_sens$Position
duplicated_indices <- duplicated(mutation_faux_pheno_rows)
suffix <- ave(seq_along(mutation_faux_pheno_rows), mutation_faux_pheno_rows, FUN = function(x) seq_along(x))
mutation_faux_pheno_rows[duplicated_indices] <- paste0(mutation_faux_pheno_rows[duplicated_indices], "_", suffix[duplicated_indices])

rownames(mutation_faux_pheno) <- mutation_faux_pheno_rows

mutation_faux_pheno[is.na(mutation_faux_pheno)] <- 0

mutation_faux_pheno <- mutation_faux_pheno %>%
  mutate_all(~ ifelse(. == "oui", 1, .))

mutation_faux_pheno <- as.data.frame(sapply(mutation_faux_pheno, as.numeric))

##PCA


pca_result <- prcomp(mutation_faux_pheno, scale. = TRUE)


summary(pca_result)
pca_data <- as.data.frame(pca_result$x[, 1:2])

num_clusters <- 10
kmeans_result <- kmeans(pca_data, centers = num_clusters)

pca_data$cluster <- as.factor(kmeans_result$cluster)

# Créer une dataframe pour stocker les données de position et de clusters
data_labels <- data.frame(Position = mutation_faux_pheno_rows, 
                          PC1 = pca_data$PC1, 
                          PC2 = pca_data$PC2,
                          cluster = pca_data$cluster)

# Fonction pour ajouter une petite valeur aléatoire à la position
add_jitter <- function(x, factor = 0.1) {
  x + runif(length(x), -factor, factor)
}

# Appliquer la fonction d'ajout de jitter aux coordonnées PC1 et PC2
data_labels$PC1_jittered <- add_jitter(data_labels$PC1)
data_labels$PC2_jittered <- add_jitter(data_labels$PC2)

# Affichage de la représentation 2D avec les clusters et les étiquettes
a = ggplot(pca_data, aes(x = PC1, y = PC2, color = cluster)) +
  geom_point() +
  geom_text(data = data_labels, aes(label = Position, x = PC1_jittered, y = PC2_jittered), hjust = 0, vjust = 0) +
  labs(x = "PC1", y = "PC2", title = "Représentation 2D avec Clustering et Labels")

print(a)

cat("\n\n")
```

### PCA table

```{r Table_PCA,  warning=FALSE, message=FALSE,fig.width=15,fig.height=15}
cluster_results <- data.frame(Position = mutation_faux_pheno_rows,
                              Clinique = mutation_non_sens$Clinique,
                              Cluster = kmeans_result$cluster)

kable(cluster_results)

```

## Repeats cb EGF like {.tabset .tabset-fade}

Description in each tab: In "Pairwise," we depict the correspondence of repeats one by one; each point represents an amino acid locus with the GEMME score (selection pressure) indicating whether the amino acid from one sequence is found in the sequence of the other and vice versa. In the heatmap tab, we provide heatmaps of mutations followed by the heatmap comparing repeats based on the GEMME score. 

```{r repeats,  warning=FALSE, message=FALSE}
# Charger les séquences alignées
aligned_sequences <- readAAStringSet("aligned_sequences.fasta")

# Sélectionner les structures EGF-like
selected_structures <- subset(Table_seq, grepl("^cb EGF-like ", Structure))

final_result_list <- list()

# Boucle à travers chaque paire de séquences
for (i in 1:(length(aligned_sequences))) {
    R1_sequence <- aligned_sequences[i]
    R1_name <- names(aligned_sequences)[i]
    results_list <- list()
    
   for (j in 1:length(aligned_sequences)) {
    if (j != i)  {
    # Extraire les informations pour la paire de séquences actuelle

    R2_sequence <- aligned_sequences[j]
    R2_name <- names(aligned_sequences)[j]

get_debut_for_name <- function(sequence_name, structures_table) {
  match_index <- grep(sequence_name, structures_table$Structure)
    if (length(match_index) > 0) {
    debut_fin_value <- structures_table$Debut_Fin[match_index]
        debut_value <- sub(";.*", "", debut_fin_value)
    
    return(debut_value)
  } else {
    return(NA)
  }
}


# Utile en avale du code 
get_end_for_name <- function(sequence_name, structures_table) {
  match_index <- grep(sequence_name, structures_table$Structure)
  
  if (length(match_index) > 0) {
    debut_fin_value <- structures_table$Debut_Fin[match_index]
    end_value <- sub(".*;", "", debut_fin_value)
    
    return(end_value)
  } else {
    return(NA)
  }
}
####


create_sequence_table <- function(sequence, debut_value) {
  sequence_table <- data.frame(
    Caractere = unlist(strsplit(as.character(sequence), "")),
    Position_Absolue = debut_value + seq_along(sequence) - 1
  )
  
  # Ajouter le décalage uniquement pour les acides aminés (et laisser NA pour les gaps)
  sequence_table$Position_Absolue <- ifelse(sequence_table$Caractere != "-", 
                                           sequence_table$Position_Absolue, NA)
  
  # Ajouter +1 aux lignes suivantes (sauf si "-")
  sequence_table$Position_Absolue[!is.na(sequence_table$Position_Absolue)] <- 
    sequence_table$Position_Absolue[!is.na(sequence_table$Position_Absolue)] +
    seq_along(sequence_table$Position_Absolue[!is.na(sequence_table$Position_Absolue)]) - 1
  rownames(sequence_table) = NULL
  return(sequence_table)
}


debut_R1 <- as.integer(get_debut_for_name(R1_name, selected_structures))
debut_R2 <- as.integer(get_debut_for_name(R2_name, selected_structures))

table_R1 <- create_sequence_table(R1_sequence, debut_R1)
table_R2 <- create_sequence_table(R2_sequence, debut_R2)

table_R1$Caractere <- tolower(table_R1$Caractere)
table_R2$Caractere <- tolower(table_R2$Caractere)

combined_R1_R2  = cbind(table_R1, table_R2)
colnames(combined_R1_R2) <- c(paste(names(table_R1), "R1", sep = "_"), paste(names(table_R2), "R2", sep = "_"))


# Joindre combined_R1_R2 avec melted_matrix sur la première condition (left join) sans trier
result1 <- merge(combined_R1_R2, melted_matrix, by.x = c("Caractere_R1", "Position_Absolue_R2"), by.y = c("AA_substitue", "Position"), all.x = TRUE, sort = FALSE)

# Joindre combined_R1_R2 avec melted_matrix sur la deuxième condition (left join) sans trier
result2 <- merge(combined_R1_R2, melted_matrix, by.x = c("Caractere_R2", "Position_Absolue_R1"), by.y = c("AA_substitue", "Position"), all.x = TRUE, sort = FALSE)
colnames(result1)[colnames(result1) == "EvolCombi"] <- "AA de R1 score dans R2"
colnames(result2)[colnames(result2) == "EvolCombi"] <- "AA de R2 score dans R1"

# Enlève les gaps de R1 
result1 <- subset(result1, !is.na(Position_Absolue_R1))
result2 <- subset(result2, !is.na(Position_Absolue_R1))


# Étape 1 : Supprimer les colonnes
result1 <- result1[, !(names(result1) %in% c("EvolCombi.Mean", "InMutationsMeanGemme"))]
result2 <- result2[, !(names(result2) %in% c("EvolCombi.Mean", "InMutationsMeanGemme"))]

# Étape 2 : Trier les résultats en tenant compte des valeurs "NA"
result1 <- result1[order(result1$Position_Absolue_R1, result1$Position_Absolue_R2), ]
result2 <- result2[order(result2$Position_Absolue_R1, result2$Position_Absolue_R2), ]



count_non_na_r1 <- sum(!is.na(result1$Position_Absolue_R1))
count_non_na_r2 <- sum(!is.na(result2$Position_Absolue_R2))


if (count_non_na_r1 == count_non_na_r2) {

  merged_results <- cbind(result1, result2[,-1]) 
} else {

  if (count_non_na_r1 > count_non_na_r2) {
    result1 <- result1[order(result1$Position_Absolue_R1), ]
    result2 <- result2[order(result2$Position_Absolue_R1), ]
  } else {
    result1 <- result1[order(result1$Position_Absolue_R2), ]
    result2 <- result2[order(result2$Position_Absolue_R2), ]
  }
  
  # Fusionner les résultats
  merged_results <- cbind(result1, result2[,-1]) 
}


combined_R1_R2 <- merged_results

combined_R1_R2 <- combined_R1_R2 %>% 
  select(unique(colnames(.)))

results_list[[R2_name]] <- combined_R1_R2



    } }
    
    
        final_result_list[[R1_name]] <- results_list



     
     }



```


```{r repeats_mutated,  warning=FALSE, message=FALSE}
# Charger les séquences alignées
aligned_sequences <- readAAStringSet("aligned_sequences.fasta")

# Sélectionner les structures EGF-like
selected_structures <- subset(Table_seq_mutated, grepl("^cb EGF-like ", Structure))

final_result_list_mutated <- list()




# Boucle à travers chaque paire de séquences
for (i in 1:(length(aligned_sequences))) {
    R1_sequence <- aligned_sequences[i]
    R1_name <- names(aligned_sequences)[i]
    results_list <- list()
    
   for (j in 1:length(aligned_sequences)) {
    if (j != i)  {
    # Extraire les informations pour la paire de séquences actuelle

    R2_sequence <- aligned_sequences[j]
    R2_name <- names(aligned_sequences)[j]

get_debut_for_name <- function(sequence_name, structures_table) {
  match_index <- grep(sequence_name, structures_table$Structure)
    if (length(match_index) > 0) {
    debut_fin_value <- structures_table$Debut_Fin[match_index]
        debut_value <- sub(";.*", "", debut_fin_value)
    
    return(debut_value)
  } else {
    return(NA)
  }
}


# Utile en avale du code 
get_end_for_name <- function(sequence_name, structures_table) {
  match_index <- grep(sequence_name, structures_table$Structure)
  
  if (length(match_index) > 0) {
    debut_fin_value <- structures_table$Debut_Fin[match_index]
    end_value <- sub(".*;", "", debut_fin_value)
    
    return(end_value)
  } else {
    return(NA)
  }
}
####


create_sequence_table <- function(sequence, debut_value) {
  sequence_table <- data.frame(
    Caractere = unlist(strsplit(as.character(sequence), "")),
    Position_Absolue = debut_value + seq_along(sequence) - 1
  )
  
  # Ajouter le décalage uniquement pour les acides aminés (et laisser NA pour les gaps)
  sequence_table$Position_Absolue <- ifelse(sequence_table$Caractere != "-", 
                                           sequence_table$Position_Absolue, NA)
  
  # Ajouter +1 aux lignes suivantes (sauf si "-")
  sequence_table$Position_Absolue[!is.na(sequence_table$Position_Absolue)] <- 
    sequence_table$Position_Absolue[!is.na(sequence_table$Position_Absolue)] +
    seq_along(sequence_table$Position_Absolue[!is.na(sequence_table$Position_Absolue)]) - 1
  rownames(sequence_table) = NULL
  return(sequence_table)
}


debut_R1 <- as.integer(get_debut_for_name(R1_name, selected_structures))
debut_R2 <- as.integer(get_debut_for_name(R2_name, selected_structures))

table_R1 <- create_sequence_table(R1_sequence, debut_R1)
table_R2 <- create_sequence_table(R2_sequence, debut_R2)

table_R1$Caractere <- tolower(table_R1$Caractere)
table_R2$Caractere <- tolower(table_R2$Caractere)

table_R1$index <- seq_len(nrow(table_R1))

table_R1$index <- seq_len(nrow(table_R1))

## Replace R1 by R1 mutated
merged_table <- merge(table_R1, mutation_non_sens, by.x = "Position_Absolue", by.y = "Position", all.x = TRUE)
merged_table$Caractere <- ifelse(!is.na(merged_table$AA_substitue), merged_table$AA_substitue, merged_table$Caractere)
merged_table <- merged_table[order(merged_table$index), ]
merged_table$index <- NULL
merged_table <- merged_table[, 1:2]
duplicated_rows <- duplicated(merged_table$Position_Absolue) & !is.na(merged_table$Position_Absolue)
merged_table <- merged_table[!duplicated_rows | is.na(merged_table$Position_Absolue), ]
table_R1 <- merged_table


combined_R1_R2  = cbind(table_R1, table_R2)
colnames(combined_R1_R2) <- c(paste(names(table_R1), "R1", sep = "_"), paste(names(table_R2), "R2", sep = "_"))


# Joindre combined_R1_R2 avec melted_matrix sur la première condition (left join) sans trier
result1 <- merge(combined_R1_R2, melted_matrix, by.x = c("Caractere_R1", "Position_Absolue_R2"), by.y = c("AA_substitue", "Position"), all.x = TRUE, sort = FALSE)

# Joindre combined_R1_R2 avec melted_matrix sur la deuxième condition (left join) sans trier
result2 <- merge(combined_R1_R2, melted_matrix, by.x = c("Caractere_R2", "Position_Absolue_R1"), by.y = c("AA_substitue", "Position"), all.x = TRUE, sort = FALSE)
colnames(result1)[colnames(result1) == "EvolCombi"] <- "AA de R1 score dans R2"
colnames(result2)[colnames(result2) == "EvolCombi"] <- "AA de R2 score dans R1"

# Enlève les gaps de R1 
result1 <- subset(result1, !is.na(Position_Absolue_R1))
result2 <- subset(result2, !is.na(Position_Absolue_R1))


# Étape 1 : Supprimer les colonnes
result1 <- result1[, !(names(result1) %in% c("EvolCombi.Mean", "InMutationsMeanGemme"))]
result2 <- result2[, !(names(result2) %in% c("EvolCombi.Mean", "InMutationsMeanGemme"))]

# Étape 2 : Trier les résultats en tenant compte des valeurs "NA"
result1 <- result1[order(result1$Position_Absolue_R1, result1$Position_Absolue_R2), ]
result2 <- result2[order(result2$Position_Absolue_R1, result2$Position_Absolue_R2), ]



count_non_na_r1 <- sum(!is.na(result1$Position_Absolue_R1))
count_non_na_r2 <- sum(!is.na(result2$Position_Absolue_R2))


if (count_non_na_r1 == count_non_na_r2) {

  merged_results <- cbind(result1, result2[,-1]) 
} else {

  if (count_non_na_r1 > count_non_na_r2) {
    result1 <- result1[order(result1$Position_Absolue_R1), ]
    result2 <- result2[order(result2$Position_Absolue_R1), ]
  } else {
    result1 <- result1[order(result1$Position_Absolue_R2), ]
    result2 <- result2[order(result2$Position_Absolue_R2), ]
  }
  
  # Fusionner les résultats
  merged_results <- cbind(result1, result2[,-1]) 
}


combined_R1_R2 <- merged_results

combined_R1_R2 <- combined_R1_R2 %>% 
  select(unique(colnames(.)))

results_list[[R2_name]] <- combined_R1_R2



    } }
    
    
        final_result_list_mutated[[R1_name]] <- results_list



     
     }



```

### Heatmaps {.tabset .tabset-fade}


Here, we examine the observed repeat sequence and determine the GEMME score that the amino acid at this position would have in another repeat

```{r repeats_heatmaps,  warning=FALSE, message=FALSE,fig.width=15,fig.height=15,results='asis'}

add_suffix <- function(names) {
  seen <- c()
  result <- character(length(names))
  for (i in seq_along(names)) {
    if (names[i] %in% seen) {
      suffix <- sum(seen == names[i])
      result[i] <- paste(names[i], suffix, sep = ".")
    } else {
      result[i] <- names[i]
    }
    seen <- c(seen, names[i])
  }
  return(result)
}


ajouter_suffixe_colonnes <- function(heatmap_data, chiffres) {
  # Vérification de la longueur
  # Modifier les noms des colonnes
  for (i in 1:length(chiffres)) { 
    colnames(heatmap_data)[i] <- paste(colnames(heatmap_data)[i], chiffres[i], sep = "$")
  }
  
  return(heatmap_data)
}

bornes = list() 
highlighted_data = list()
heatmap_datas = list()
# Boucle à travers chaque élément R1 de final_result_list
for (R1_name in names(final_result_list)) {
    cat("\n\n")
  cat("#### ",R1_name)
  cat("\n\n")

    results_list <- final_result_list[[R1_name]]
    
    if (R1_name == "cb EGF-like #02"){
        NCOL =  dim(final_result_list[[R1_name]]$`cb EGF-like #01`)[1]
    } else {
        NCOL =  dim(final_result_list[[R1_name]]$`cb EGF-like #02`)[1]
    }
    heatmap_data <- matrix(nrow = 42, ncol = NCOL)

    row_names_except_current <- setdiff(names(final_result_list), R1_name)
    
    if (R1_name == "cb EGF-like #02"){
        colnames(heatmap_data) <- final_result_list[[R1_name]]$`cb EGF-like #01`$Caractere_R1
        locus <- final_result_list[[R1_name]]$`cb EGF-like #01`$Position_Absolue_R1
    
    } else {
       colnames(heatmap_data) <- final_result_list[[R1_name]]$`cb EGF-like #02`$Caractere_R1
       locus <- final_result_list[[R1_name]]$`cb EGF-like #02`$Position_Absolue_R1
     
    }
    
    new_colnames <- add_suffix(colnames(heatmap_data))
    rownames(heatmap_data) <- row_names_except_current
    
    colnames(heatmap_data) = locus
    
    heatmap_data_car = heatmap_data
    
    
for (R2_name in row_names_except_current) {
    # Récupérer les scores depuis final_result_list
    scores <- final_result_list[[R1_name]][[R2_name]]$`AA de R1 score dans R2`
    
    # Récupérer les caractéristiques
    caractere_R2 <- final_result_list[[R1_name]][[R2_name]]$`Caractere_R2`
    
    # Trouver l'index de la ligne correspondant au R2_name dans la matrice
    row_index <- match(R2_name, row_names_except_current)
    
    # Assigner les scores à la ligne appropriée dans la matrice
    heatmap_data[row_index, ] <- scores
    heatmap_data_car[row_index, ] <- caractere_R2
    

}


# Convertir la matrice en un format long
heatmap_data_long <- melt(heatmap_data)
heatmap_data_car_long<- melt(heatmap_data_car)
merged_heatmap_data <- merge(heatmap_data_long, heatmap_data_car_long, by = c("Var1", "Var2"))




indices_a_marquer <- mutation_non_sens$Position
mutation_a_marquer <- data_frame("Position" =  mutation_non_sens$Position, "a.a" = mutation_non_sens$AA_substitue)


merged_heatmap_data$is_index_to_mark <- ifelse(merged_heatmap_data$Var2 %in% indices_a_marquer, TRUE, FALSE)
merged_heatmap_data$aa_patho <- ifelse(merged_heatmap_data$is_index_to_mark & 
                                           merged_heatmap_data$Var2 %in% mutation_a_marquer$Position,
                                       mutation_a_marquer$a.a[match(merged_heatmap_data$Var2, mutation_a_marquer$Position)],
                                       NA)


merged_heatmap_data$mutation_other_read <- ifelse(
  merged_heatmap_data$Var2 == mutation_a_marquer$Position & 
  merged_heatmap_data$value.y == mutation_a_marquer$a.a,
  TRUE,
  FALSE
)

merged_heatmap_data <- merged_heatmap_data %>%
  arrange(Var2)
#Permet d'avoir les acides aminés 
colnames(heatmap_data) = new_colnames
heatmap_data_long2 = melt(heatmap_data)
merged_heatmap_data$Var2 = heatmap_data_long2$Var2



highlighted_data[[R1_name]] <- row.names(merged_heatmap_data[merged_heatmap_data$mutation_other_read == TRUE, ])
heatmap_datas [[R1_name]]<- merged_heatmap_data
# Plotting code
d_plot <- ggplot(merged_heatmap_data, aes(Var2, Var1)) +
  labs(x = R1_name, y = "Repeats") + 
  geom_tile(aes(fill = value.x), color = "black") +  # Ajout des cases de heatmap
  geom_text(aes(label = value.y, color = mutation_other_read), size = 3) +  # Ajout des valeurs de value.y avec couleur basée sur mutation_other_read
  geom_text(aes(label = value.y, color = is_index_to_mark), size = 3) +  # Ajout des valeurs de value.y avec couleur basée sur is_index_to_mark
  scale_fill_gradient2(low = "red", mid = "yellow", high = "white",
                       midpoint = -3, name = "selection pressure") +
  scale_color_manual(values = c("black", "blue"), guide = FALSE) +  # Couleurs des textes basées sur les colonnes ajoutées
  guides(fill = guide_legend(title = "selection pressure"),
         color = guide_legend(title = NULL, override.aes = list(size = 5))) +  # Personnalisation des légendes
  theme(legend.position = "bottom")  # Position de la légende

print(d_plot)

  cat("\n\n")
   cat("\n\n")





 }



    
```





### Heatmaps reciproque  {.tabset .tabset-fade}


Here, we look at the GEMME score of an amino acid in one of the repeats relative to the position of the repeat being examined.

```{r repeats_heatmaps_reciproque,  warning=FALSE, message=FALSE,fig.width=15,fig.height=15,results='asis'}



bornes = list() 
highlighted_data_rec = list()
heatmap_datas_rec = list()
# Boucle à travers chaque élément R1 de final_result_list
for (R1_name in names(final_result_list)) {
    cat("\n\n")
  cat("#### ",R1_name)
  cat("\n\n")
 

    results_list <- final_result_list[[R1_name]]
    
    if (R1_name == "cb EGF-like #02"){
        NCOL =  dim(final_result_list[[R1_name]]$`cb EGF-like #01`)[1]
    } else {
        NCOL =  dim(final_result_list[[R1_name]]$`cb EGF-like #02`)[1]
    }
    heatmap_data <- matrix(nrow = 42, ncol = NCOL)

    row_names_except_current <- setdiff(names(final_result_list), R1_name)
    
    if (R1_name == "cb EGF-like #02"){
        colnames(heatmap_data) <- final_result_list[[R1_name]]$`cb EGF-like #01`$Caractere_R1
        locus <- final_result_list[[R1_name]]$`cb EGF-like #01`$Position_Absolue_R1
    
    } else {
       colnames(heatmap_data) <- final_result_list[[R1_name]]$`cb EGF-like #02`$Caractere_R1
       locus <- final_result_list[[R1_name]]$`cb EGF-like #02`$Position_Absolue_R1
     
    }
    
    new_colnames <- add_suffix(colnames(heatmap_data))
    rownames(heatmap_data) <- row_names_except_current
    
    colnames(heatmap_data) = locus
    
    heatmap_data_car = heatmap_data
    
    
for (R2_name in row_names_except_current) {
    # Récupérer les scores depuis final_result_list
    scores <- final_result_list[[R1_name]][[R2_name]]$`AA de R2 score dans R1`
    
    # Récupérer les caractéristiques
    caractere_R2 <- final_result_list[[R1_name]][[R2_name]]$`Caractere_R2`
    
    # Trouver l'index de la ligne correspondant au R2_name dans la matrice
    row_index <- match(R2_name, row_names_except_current)
    
    # Assigner les scores à la ligne appropriée dans la matrice
    heatmap_data[row_index, ] <- scores
    heatmap_data_car[row_index, ] <- caractere_R2
    

}


# Convertir la matrice en un format long
heatmap_data_long <- melt(heatmap_data)
heatmap_data_car_long<- melt(heatmap_data_car)
merged_heatmap_data <- merge(heatmap_data_long, heatmap_data_car_long, by = c("Var1", "Var2"))


# Supposons que 'mutations_non_sens$Position' est un vecteur d'indices à marquer
indices_a_marquer <- mutation_non_sens$Position
mutation_a_marquer <- data_frame("Position" =  mutation_non_sens$Position, "a.a" = mutation_non_sens$AA_substitue)

# Ajouter une colonne pour vérifier si l'indice est dans 'indices_a_marquer'
merged_heatmap_data$is_index_to_mark <- ifelse(merged_heatmap_data$Var2 %in% indices_a_marquer, TRUE, FALSE)
merged_heatmap_data$mutation_other_read <- ifelse(
  merged_heatmap_data$Var2 == mutation_a_marquer$Position & 
  merged_heatmap_data$value.y == mutation_a_marquer$a.a,
  TRUE,
  FALSE
)

merged_heatmap_data <- merged_heatmap_data %>%
  arrange(Var2)
#Permet d'avoir les acides aminés 
colnames(heatmap_data) = new_colnames
heatmap_data_long2 = melt(heatmap_data)
merged_heatmap_data$Var2 = heatmap_data_long2$Var2



highlighted_data_rec[[R1_name]] <- row.names(merged_heatmap_data[merged_heatmap_data$mutation_other_read == TRUE, ])
heatmap_datas_rec[[R1_name]]<- merged_heatmap_data
# Plotting code
d_plot <- ggplot(merged_heatmap_data, aes(Var2, Var1)) +
  labs(x = R1_name, y = "Repeats") + 
  geom_tile(aes(fill = value.x), color = "black") +  # Ajout des cases de heatmap
  geom_text(aes(label = value.y, color = mutation_other_read), size = 3) +  # Ajout des valeurs de value.y avec couleur basée sur mutation_other_read
  geom_text(aes(label = value.y, color = is_index_to_mark), size = 3) +  # Ajout des valeurs de value.y avec couleur basée sur is_index_to_mark
  scale_fill_gradient2(low = "red", mid = "yellow", high = "white",
                       midpoint = -3, name = "selection pressure") +
  scale_color_manual(values = c("black", "blue"), guide = FALSE) +  # Couleurs des textes basées sur les colonnes ajoutées
  guides(fill = guide_legend(title = "selection pressure"),
         color = guide_legend(title = NULL, override.aes = list(size = 5))) +  # Personnalisation des légendes
  theme(legend.position = "bottom")  # Position de la légende

print(d_plot)


cat("\n\n")
cat("\n\n")




 }


cat("\n\n")
    
```
### Heatmaps mutated {.tabset .tabset-fade}

Same as the first heatmap but instead of the WT it is the mutated sequence 


```{r repeats_heatmaps_mutated,  warning=FALSE, message=FALSE,fig.width=15,fig.height=15,results='asis'}



bornes = list() 
highlighted_data_mutated = list()
heatmap_datas_mutated = list()
# Boucle à travers chaque élément R1 de final_result_list_mutated
for (R1_name in names(final_result_list_mutated)) {
    cat("\n\n")
  cat("#### ",R1_name)
  cat("\n\n")

    results_list <- final_result_list_mutated[[R1_name]]
    
    if (R1_name == "cb EGF-like #02"){
        NCOL =  dim(final_result_list_mutated[[R1_name]]$`cb EGF-like #01`)[1]
    } else {
        NCOL =  dim(final_result_list_mutated[[R1_name]]$`cb EGF-like #02`)[1]
    }
    heatmap_data <- matrix(nrow = 42, ncol = NCOL)

    row_names_except_current <- setdiff(names(final_result_list_mutated), R1_name)
    
    if (R1_name == "cb EGF-like #02"){
        colnames(heatmap_data) <- final_result_list_mutated[[R1_name]]$`cb EGF-like #01`$Caractere_R1
        locus <- final_result_list_mutated[[R1_name]]$`cb EGF-like #01`$Position_Absolue_R1
    
    } else {
       colnames(heatmap_data) <- final_result_list_mutated[[R1_name]]$`cb EGF-like #02`$Caractere_R1
       locus <- final_result_list_mutated[[R1_name]]$`cb EGF-like #02`$Position_Absolue_R1
     
    }
    
    new_colnames <- add_suffix(colnames(heatmap_data))
    rownames(heatmap_data) <- row_names_except_current
    
    colnames(heatmap_data) = locus
    
    heatmap_data_car = heatmap_data
    
    
for (R2_name in row_names_except_current) {
    # Récupérer les scores depuis final_result_list_mutated
    scores <- final_result_list_mutated[[R1_name]][[R2_name]]$`AA de R1 score dans R2`
    
    # Récupérer les caractéristiques
    caractere_R2 <- final_result_list_mutated[[R1_name]][[R2_name]]$`Caractere_R2`
    
    # Trouver l'index de la ligne correspondant au R2_name dans la matrice
    row_index <- match(R2_name, row_names_except_current)
    
    # Assigner les scores à la ligne appropriée dans la matrice
    heatmap_data[row_index, ] <- scores
    heatmap_data_car[row_index, ] <- caractere_R2
    

}


# Convertir la matrice en un format long
heatmap_data_long <- melt(heatmap_data)
heatmap_data_car_long<- melt(heatmap_data_car)
merged_heatmap_data <- merge(heatmap_data_long, heatmap_data_car_long, by = c("Var1", "Var2"))



indices_a_marquer <- mutation_non_sens$Position
mutation_a_marquer <- data_frame("Position" =  mutation_non_sens$Position, "a.a" = mutation_non_sens$AA_substitue)


merged_heatmap_data$is_index_to_mark <- ifelse(merged_heatmap_data$Var2 %in% indices_a_marquer, TRUE, FALSE)

merged_heatmap_data$mutation_other_read <- ifelse(
  merged_heatmap_data$Var2 == mutation_a_marquer$Position & 
  merged_heatmap_data$value.y == mutation_a_marquer$a.a,
  TRUE,
  FALSE
)

merged_heatmap_data <- merged_heatmap_data %>%
  arrange(Var2)
#Permet d'avoir les acides aminés 
colnames(heatmap_data) = new_colnames
heatmap_data_long2 = melt(heatmap_data)
merged_heatmap_data$Var2 = heatmap_data_long2$Var2



highlighted_data_mutated[[R1_name]] <- row.names(merged_heatmap_data[merged_heatmap_data$mutation_other_read == TRUE, ])
heatmap_datas_mutated[[R1_name]]<- merged_heatmap_data
# Plotting code
d_plot <- ggplot(merged_heatmap_data, aes(Var2, Var1)) +
  labs(x = R1_name, y = "Repeats") + 
  geom_tile(aes(fill = value.x), color = "black") +  # Ajout des cases de heatmap
  geom_text(aes(label = value.y, color = mutation_other_read), size = 3) +  # Ajout des valeurs de value.y avec couleur basée sur mutation_other_read
  geom_text(aes(label = value.y, color = is_index_to_mark), size = 3) +  # Ajout des valeurs de value.y avec couleur basée sur is_index_to_mark
  scale_fill_gradient2(low = "red", mid = "yellow", high = "white",
                       midpoint = -3, name = "selection pressure") +
  scale_color_manual(values = c("black", "blue"), guide = FALSE) +  # Couleurs des textes basées sur les colonnes ajoutées
  guides(fill = guide_legend(title = "selection pressure"),
         color = guide_legend(title = NULL, override.aes = list(size = 5))) +  # Personnalisation des légendes
  theme(legend.position = "bottom")  # Position de la légende

print(d_plot)





  cat("\n\n")
   cat("\n\n")

 }



    
```

### Logos  {.tabset .tabset-fade}

Here we have for each CB EGF-like repeat, 3 logos. 

The first one represents the heatmap of the repeat being observed versus the others. In summary, the larger the letter, the higher its average selection pressure score is with a threshold (see below). In other words, the larger the letter, the more it is 'forbidden' in the dimensions of CB EGF-like. For the third logo, it's exactly the same principle, but the WT sequence of the repeat is replaced by the sequence with the mutated amino acids (if two substituting AAs are found, then only one of the two is chosen). 

The second logo is a score given for the most allowed amino acids at the position of the observed repeat. It relies more on the green matrices mentioned earlier in this report. The calculation for the allowed score is as follows:

\[ \text{letter\_size\_pow100} = 10 \times \text{letter\_size} \]

Where \(\text{letter\_size}\) is determined by the condition:

\[ \begin{cases}
\max(\text{abs\_Value\_log}) + 1 & \text{if } \text{abs\_Value} = 0 \\
\max(\text{abs\_Value\_log}) - \text{abs\_Value\_log} + 1 & \text{otherwise}
\end{cases} \]

And \(\text{abs\_Value\_log}\) is calculated as:

\[ \text{abs\_Value\_log} = \log(\text{abs\_Value} + 1) \]


```{r Logo,  warning=FALSE, message=FALSE, fig.width=20 ,fig.height=5, results= 'asis'}
cat("treshold for Logo of forbidden aa : ",treshold)
PCA_data_long <- read.csv("PCA_data_long.csv")
all_gemme_add_mutated_list <- list()
all_gemme_add_list <- list()
Scores <- list()
for (R1_name in names(final_result_list)) {
  cat("\n\n")
  cat("#### ",R1_name)
  cat("\n\n")

   
  
  
  debut_R1 <- as.integer(get_debut_for_name(R1_name, selected_structures))
  end_R1 <- as.integer(get_end_for_name(R1_name, selected_structures))
  intervalle <- c(debut_R1, end_R1)
  bornes[[R1_name]] <- intervalle
  numeros_lignes <- seq.int(debut_R1, end_R1)
  # Plot 1 : ggplot pour data_filtre
  data_filtre <- data_long_ori %>%
    filter(ColumnNames >= debut_R1 & ColumnNames <= end_R1) %>%
    replace_na(list(Value = 0)) %>%
    mutate(abs_Value = abs(Value),
           abs_Value_log = log(abs_Value + 1),
           letter_size = ifelse(abs_Value == 0, max(abs_Value_log) + 1, max(abs_Value_log) - abs_Value_log + 1),
           letter_size_pow100 = 10 ^ letter_size) 
  
  
  
  
## Biochemic info 
data(sequences)
acides_amines_dict <- unique(ggfortify(sequences, peptide, treatment = class)[, c("element", "Polarity", "Water")])
data_filtre$AA <- toupper(data_filtre$RowNames)
data_filtre <- merge(data_filtre, acides_amines_dict, by.x = "AA", by.y = "element", all.x = TRUE)
  
  plot <- ggplot(data = data_filtre) + 
    geom_logo(aes(x = ColumnNames, y = letter_size_pow100, label = AA, fill = interaction(Polarity, Water)),
              alpha = 0.6, position = "fill", color = "transparent")  +
    labs(x =" ", y = "Allowed") +
    scale_x_continuous(breaks = numeros_lignes) +
        theme(plot.title = element_text(size = 100),
          plot.subtitle = element_text(size = 40), 
          plot.caption = element_text(size = 100), 
          axis.title = element_text(size = 10)) 
  
  # Plot 2 : ggplot pour Gemme_add
activation = 4


Gemme_add <- heatmap_datas[[R1_name]] %>%
  group_by(Var2) %>%
  summarize(
    total_count = n(),  
    Somme_value_x_abs = mean(abs(value.x), na.rm = TRUE),
    score = sum(abs(value.x) > activation, na.rm = TRUE) / n() 
  ) %>%
  mutate(
    AA = gsub("[^[:alpha:]]", "", Var2),
    Numero_ligne = numeros_lignes
  )

# Traitement initial pour Gemme_add_mutated
Gemme_add_mutated <- heatmap_datas_mutated[[R1_name]] %>%
  group_by(Var2) %>%
  summarize(
    total_count = n(),  
    Somme_value_x_abs = mean(abs(value.x), na.rm = TRUE),
    score = sum(abs(value.x) > activation, na.rm = TRUE) / n() 
  ) %>%
  mutate(
    AA = gsub("[^[:alpha:]]", "", Var2),
    Numero_ligne = numeros_lignes
  )

combined_df <- left_join(Gemme_add, Gemme_add_mutated, by = "Numero_ligne", suffix = c("_WT", "_mutated"))

combined_df <- combined_df %>%
  mutate(ratio_score = score_mutated / score_WT) %>%
  select(Numero_ligne, AA_WT, AA_mutated, score_WT, score_mutated, ratio_score) 

colnames(combined_df)[colnames(combined_df) == "Numero_ligne"] <- "Position"




Gemme_add <- Gemme_add %>%
  mutate(Somme_value_x_abs = ifelse(Somme_value_x_abs < treshold, 0, Somme_value_x_abs))
Gemme_add_mutated <- Gemme_add_mutated %>%
  mutate(Somme_value_x_abs = ifelse(Somme_value_x_abs < treshold, 0, Somme_value_x_abs))




## Biochemic info 
acides_amines_dict <- unique(ggfortify(sequences, peptide, treatment = class)[, c("element", "Polarity", "Water")])
Gemme_add$AA <- toupper(Gemme_add$AA)
Gemme_add_mutated$AA <- toupper(Gemme_add_mutated$AA)
Gemme_add <- merge(Gemme_add, acides_amines_dict, by.x = "AA", by.y = "element", all.x = TRUE)
Gemme_add_mutated <- merge(Gemme_add_mutated, acides_amines_dict, by.x = "AA", by.y = "element", all.x = TRUE)



  
  plot_logo <- ggplot(data = Gemme_add ) +
    geom_logo(aes(x = Numero_ligne, y = Somme_value_x_abs, label = AA, fill = interaction(Polarity, Water)),alpha = 0.6,position = "classic",color="transparent") +
    labs(x =" ",y = "Forbidden")     +
    scale_x_continuous(breaks = numeros_lignes) + theme(legend.position = "none") +     scale_x_continuous(breaks = numeros_lignes) +
        theme(plot.title = element_text(size = 40),
          plot.subtitle = element_text(size = 40), 
          plot.caption = element_text(size = 40), 
          axis.title = element_text(size = 10)) 
  
  plot_mut <- ggplot(data = Gemme_add_mutated ) +
    geom_logo(aes(x = Numero_ligne, y = Somme_value_x_abs, label = AA, fill = interaction(Polarity, Water)),alpha = 0.6,position = "classic",color="transparent") +
    labs(x = paste("sequence",R1_name), y = "Forbidden pathogen")   +
    scale_x_continuous(breaks = numeros_lignes) + theme(legend.position = "none") +     scale_x_continuous(breaks = numeros_lignes) +
        theme(plot.title = element_text(size = 40),
          plot.subtitle = element_text(size = 40), 
          plot.caption = element_text(size = 40), 
          axis.title = element_text(size = 10)) 
  
  
  # Combinaison des deux graphiques et ajustements
  combined_plot <- plot_logo + plot + plot_mut + plot_layout(nrow = 3, heights = c(1, 3))  # 
  
  # Afficher le graphique combiné
  print(combined_plot)
  
 
all_gemme_add_list[[R1_name]] <- Gemme_add
all_gemme_add_mutated_list[[R1_name]] <- Gemme_add_mutated
Scores[[R1_name]] = combined_df 
  cat("\n\n")
   cat("\n\n")
}



All_Gemme_add <- bind_rows(all_gemme_add_list)
All_Gemme_add_mutated <- bind_rows(all_gemme_add_mutated_list) 
All_Gemme_add_combined <- bind_rows(All_Gemme_add, All_Gemme_add_mutated)
All_Gemme_add_combined <- All_Gemme_add_combined %>%
  distinct(AA, Numero_ligne, .keep_all = TRUE)

score <- bind_rows(Scores)
All_Gemme_add_combined <- All_Gemme_add_combined %>%
  mutate(
    Var2 = substr(Var2, 1, 1)
    
  )

PCA_data_long <- PCA_data_long %>%
  left_join(All_Gemme_add_combined, by = c("AA_substitue" = "Var2", "Position" = "Numero_ligne"))
PCA_data_long <- PCA_data_long[, !names(PCA_data_long) %in% c("Var2", "Polarity_mutated", "Water_mutated")]
PCA_data_long <- PCA_data_long %>%
  select(-AA_substitue)



write.csv(score, "scores_cb_EGF_like.csv", row.names = FALSE)
write.csv(PCA_data_long, "PCA_data_long.csv", row.names = FALSE)


```


## Repeats EGF like {.tabset .tabset-fade}

Description in each tab: In "Pairwise," we depict the correspondence of repeats one by one; each point represents an amino acid locus with the GEMME score (selection pressure) indicating whether the amino acid from one sequence is found in the sequence of the other and vice versa. In the heatmap tab, we provide heatmaps of mutations followed by the heatmap comparing repeats based on the GEMME score. 

```{r repeats,  warning=FALSE, message=FALSE}
# Charger les séquences alignées
aligned_sequences <- readAAStringSet("aligned_EGF_like_sequences.fasta")

# Sélectionner les structures EGF-like
selected_structures <- subset(Table_seq, grepl("^EGF-like", Structure))

final_result_list <- list()

# Boucle à travers chaque paire de séquences
for (i in 1:(length(aligned_sequences))) {
    R1_sequence <- aligned_sequences[i]
    R1_name <- names(aligned_sequences)[i]
    results_list <- list()
    
   for (j in 1:length(aligned_sequences)) {
    if (j != i)  {
    # Extraire les informations pour la paire de séquences actuelle

    R2_sequence <- aligned_sequences[j]
    R2_name <- names(aligned_sequences)[j]

get_debut_for_name <- function(sequence_name, structures_table) {
  match_index <- grep(sequence_name, structures_table$Structure)
    if (length(match_index) > 0) {
    debut_fin_value <- structures_table$Debut_Fin[match_index]
        debut_value <- sub(";.*", "", debut_fin_value)
    
    return(debut_value)
  } else {
    return(NA)
  }
}


# Utile en avale du code 
get_end_for_name <- function(sequence_name, structures_table) {
  match_index <- grep(sequence_name, structures_table$Structure)
  
  if (length(match_index) > 0) {
    debut_fin_value <- structures_table$Debut_Fin[match_index]
    end_value <- sub(".*;", "", debut_fin_value)
    
    return(end_value)
  } else {
    return(NA)
  }
}
####


create_sequence_table <- function(sequence, debut_value) {
  sequence_table <- data.frame(
    Caractere = unlist(strsplit(as.character(sequence), "")),
    Position_Absolue = debut_value + seq_along(sequence) - 1
  )
  
  # Ajouter le décalage uniquement pour les acides aminés (et laisser NA pour les gaps)
  sequence_table$Position_Absolue <- ifelse(sequence_table$Caractere != "-", 
                                           sequence_table$Position_Absolue, NA)
  
  # Ajouter +1 aux lignes suivantes (sauf si "-")
  sequence_table$Position_Absolue[!is.na(sequence_table$Position_Absolue)] <- 
    sequence_table$Position_Absolue[!is.na(sequence_table$Position_Absolue)] +
    seq_along(sequence_table$Position_Absolue[!is.na(sequence_table$Position_Absolue)]) - 1
  rownames(sequence_table) = NULL
  return(sequence_table)
}


debut_R1 <- as.integer(get_debut_for_name(R1_name, selected_structures))
debut_R2 <- as.integer(get_debut_for_name(R2_name, selected_structures))

table_R1 <- create_sequence_table(R1_sequence, debut_R1)
table_R2 <- create_sequence_table(R2_sequence, debut_R2)

table_R1$Caractere <- tolower(table_R1$Caractere)
table_R2$Caractere <- tolower(table_R2$Caractere)

combined_R1_R2  = cbind(table_R1, table_R2)
colnames(combined_R1_R2) <- c(paste(names(table_R1), "R1", sep = "_"), paste(names(table_R2), "R2", sep = "_"))


# Joindre combined_R1_R2 avec melted_matrix sur la première condition (left join) sans trier
result1 <- merge(combined_R1_R2, melted_matrix, by.x = c("Caractere_R1", "Position_Absolue_R2"), by.y = c("AA_substitue", "Position"), all.x = TRUE, sort = FALSE)

# Joindre combined_R1_R2 avec melted_matrix sur la deuxième condition (left join) sans trier
result2 <- merge(combined_R1_R2, melted_matrix, by.x = c("Caractere_R2", "Position_Absolue_R1"), by.y = c("AA_substitue", "Position"), all.x = TRUE, sort = FALSE)
colnames(result1)[colnames(result1) == "EvolCombi"] <- "AA de R1 score dans R2"
colnames(result2)[colnames(result2) == "EvolCombi"] <- "AA de R2 score dans R1"

# Enlève les gaps de R1 
result1 <- subset(result1, !is.na(Position_Absolue_R1))
result2 <- subset(result2, !is.na(Position_Absolue_R1))


# Étape 1 : Supprimer les colonnes
result1 <- result1[, !(names(result1) %in% c("EvolCombi.Mean", "InMutationsMeanGemme"))]
result2 <- result2[, !(names(result2) %in% c("EvolCombi.Mean", "InMutationsMeanGemme"))]

# Étape 2 : Trier les résultats en tenant compte des valeurs "NA"
result1 <- result1[order(result1$Position_Absolue_R1, result1$Position_Absolue_R2), ]
result2 <- result2[order(result2$Position_Absolue_R1, result2$Position_Absolue_R2), ]



count_non_na_r1 <- sum(!is.na(result1$Position_Absolue_R1))
count_non_na_r2 <- sum(!is.na(result2$Position_Absolue_R2))


if (count_non_na_r1 == count_non_na_r2) {

  merged_results <- cbind(result1, result2[,-1]) 
} else {

  if (count_non_na_r1 > count_non_na_r2) {
    result1 <- result1[order(result1$Position_Absolue_R1), ]
    result2 <- result2[order(result2$Position_Absolue_R1), ]
  } else {
    result1 <- result1[order(result1$Position_Absolue_R2), ]
    result2 <- result2[order(result2$Position_Absolue_R2), ]
  }
  
  # Fusionner les résultats
  merged_results <- cbind(result1, result2[,-1]) 
}


combined_R1_R2 <- merged_results

combined_R1_R2 <- combined_R1_R2 %>% 
  select(unique(colnames(.)))

results_list[[R2_name]] <- combined_R1_R2



    } }
    
    
        final_result_list[[R1_name]] <- results_list



     
     }



```


```{r repeats_mutated,  warning=FALSE, message=FALSE}
# Charger les séquences alignées
aligned_sequences <- readAAStringSet("aligned_EGF_like_sequences.fasta")

# Sélectionner les structures EGF-like
selected_structures <- subset(Table_seq_mutated, grepl("^EGF-like", Structure))

final_result_list_mutated <- list()




# Boucle à travers chaque paire de séquences
for (i in 1:(length(aligned_sequences))) {
    R1_sequence <- aligned_sequences[i]
    R1_name <- names(aligned_sequences)[i]
    results_list <- list()
    
   for (j in 1:length(aligned_sequences)) {
    if (j != i)  {
    # Extraire les informations pour la paire de séquences actuelle

    R2_sequence <- aligned_sequences[j]
    R2_name <- names(aligned_sequences)[j]

get_debut_for_name <- function(sequence_name, structures_table) {
  match_index <- grep(sequence_name, structures_table$Structure)
    if (length(match_index) > 0) {
    debut_fin_value <- structures_table$Debut_Fin[match_index]
        debut_value <- sub(";.*", "", debut_fin_value)
    
    return(debut_value)
  } else {
    return(NA)
  }
}


# Utile en avale du code 
get_end_for_name <- function(sequence_name, structures_table) {
  match_index <- grep(sequence_name, structures_table$Structure)
  
  if (length(match_index) > 0) {
    debut_fin_value <- structures_table$Debut_Fin[match_index]
    end_value <- sub(".*;", "", debut_fin_value)
    
    return(end_value)
  } else {
    return(NA)
  }
}
####


create_sequence_table <- function(sequence, debut_value) {
  sequence_table <- data.frame(
    Caractere = unlist(strsplit(as.character(sequence), "")),
    Position_Absolue = debut_value + seq_along(sequence) - 1
  )
  
  # Ajouter le décalage uniquement pour les acides aminés (et laisser NA pour les gaps)
  sequence_table$Position_Absolue <- ifelse(sequence_table$Caractere != "-", 
                                           sequence_table$Position_Absolue, NA)
  
  # Ajouter +1 aux lignes suivantes (sauf si "-")
  sequence_table$Position_Absolue[!is.na(sequence_table$Position_Absolue)] <- 
    sequence_table$Position_Absolue[!is.na(sequence_table$Position_Absolue)] +
    seq_along(sequence_table$Position_Absolue[!is.na(sequence_table$Position_Absolue)]) - 1
  rownames(sequence_table) = NULL
  return(sequence_table)
}


debut_R1 <- as.integer(get_debut_for_name(R1_name, selected_structures))
debut_R2 <- as.integer(get_debut_for_name(R2_name, selected_structures))

table_R1 <- create_sequence_table(R1_sequence, debut_R1)
table_R2 <- create_sequence_table(R2_sequence, debut_R2)

table_R1$Caractere <- tolower(table_R1$Caractere)
table_R2$Caractere <- tolower(table_R2$Caractere)

table_R1$index <- seq_len(nrow(table_R1))

table_R1$index <- seq_len(nrow(table_R1))

## Replace R1 by R1 mutated
merged_table <- merge(table_R1, mutation_non_sens, by.x = "Position_Absolue", by.y = "Position", all.x = TRUE)
merged_table$Caractere <- ifelse(!is.na(merged_table$AA_substitue), merged_table$AA_substitue, merged_table$Caractere)
merged_table <- merged_table[order(merged_table$index), ]
merged_table$index <- NULL
merged_table <- merged_table[, 1:2]
duplicated_rows <- duplicated(merged_table$Position_Absolue) & !is.na(merged_table$Position_Absolue)
merged_table <- merged_table[!duplicated_rows | is.na(merged_table$Position_Absolue), ]
table_R1 <- merged_table


combined_R1_R2  = cbind(table_R1, table_R2)
colnames(combined_R1_R2) <- c(paste(names(table_R1), "R1", sep = "_"), paste(names(table_R2), "R2", sep = "_"))


# Joindre combined_R1_R2 avec melted_matrix sur la première condition (left join) sans trier
result1 <- merge(combined_R1_R2, melted_matrix, by.x = c("Caractere_R1", "Position_Absolue_R2"), by.y = c("AA_substitue", "Position"), all.x = TRUE, sort = FALSE)

# Joindre combined_R1_R2 avec melted_matrix sur la deuxième condition (left join) sans trier
result2 <- merge(combined_R1_R2, melted_matrix, by.x = c("Caractere_R2", "Position_Absolue_R1"), by.y = c("AA_substitue", "Position"), all.x = TRUE, sort = FALSE)
colnames(result1)[colnames(result1) == "EvolCombi"] <- "AA de R1 score dans R2"
colnames(result2)[colnames(result2) == "EvolCombi"] <- "AA de R2 score dans R1"

# Enlève les gaps de R1 
result1 <- subset(result1, !is.na(Position_Absolue_R1))
result2 <- subset(result2, !is.na(Position_Absolue_R1))


# Étape 1 : Supprimer les colonnes
result1 <- result1[, !(names(result1) %in% c("EvolCombi.Mean", "InMutationsMeanGemme"))]
result2 <- result2[, !(names(result2) %in% c("EvolCombi.Mean", "InMutationsMeanGemme"))]

# Étape 2 : Trier les résultats en tenant compte des valeurs "NA"
result1 <- result1[order(result1$Position_Absolue_R1, result1$Position_Absolue_R2), ]
result2 <- result2[order(result2$Position_Absolue_R1, result2$Position_Absolue_R2), ]



count_non_na_r1 <- sum(!is.na(result1$Position_Absolue_R1))
count_non_na_r2 <- sum(!is.na(result2$Position_Absolue_R2))


if (count_non_na_r1 == count_non_na_r2) {

  merged_results <- cbind(result1, result2[,-1]) 
} else {

  if (count_non_na_r1 > count_non_na_r2) {
    result1 <- result1[order(result1$Position_Absolue_R1), ]
    result2 <- result2[order(result2$Position_Absolue_R1), ]
  } else {
    result1 <- result1[order(result1$Position_Absolue_R2), ]
    result2 <- result2[order(result2$Position_Absolue_R2), ]
  }
  
  # Fusionner les résultats
  merged_results <- cbind(result1, result2[,-1]) 
}


combined_R1_R2 <- merged_results

combined_R1_R2 <- combined_R1_R2 %>% 
  select(unique(colnames(.)))

results_list[[R2_name]] <- combined_R1_R2



    } }
    
    
        final_result_list_mutated[[R1_name]] <- results_list



     
     }



```

### Heatmaps {.tabset .tabset-fade}


Here, we examine the observed repeat sequence and determine the GEMME score that the amino acid at this position would have in another repeat

```{r repeats_heatmaps,  warning=FALSE, message=FALSE,fig.width=15,fig.height=15,results='asis'}

add_suffix <- function(names) {
  seen <- c()
  result <- character(length(names))
  for (i in seq_along(names)) {
    if (names[i] %in% seen) {
      suffix <- sum(seen == names[i])
      result[i] <- paste(names[i], suffix, sep = ".")
    } else {
      result[i] <- names[i]
    }
    seen <- c(seen, names[i])
  }
  return(result)
}


ajouter_suffixe_colonnes <- function(heatmap_data, chiffres) {
  # Vérification de la longueur
  # Modifier les noms des colonnes
  for (i in 1:length(chiffres)) { 
    colnames(heatmap_data)[i] <- paste(colnames(heatmap_data)[i], chiffres[i], sep = "$")
  }
  
  return(heatmap_data)
}

bornes = list() 
highlighted_data = list()
heatmap_datas = list()
# Boucle à travers chaque élément R1 de final_result_list
for (R1_name in names(final_result_list)) {
    cat("\n\n")
  cat("#### ",R1_name)
  cat("\n\n")

    results_list <- final_result_list[[R1_name]]
    
    if (R1_name == "EGF-like #02"){
        NCOL =  dim(final_result_list[[R1_name]]$`EGF-like #01`)[1]
    } else {
        NCOL =  dim(final_result_list[[R1_name]]$`EGF-like #02`)[1]
    }
    heatmap_data <- matrix(nrow = 3, ncol = NCOL)

    row_names_except_current <- setdiff(names(final_result_list), R1_name)
    
    if (R1_name == "EGF-like #02"){
        colnames(heatmap_data) <- final_result_list[[R1_name]]$`EGF-like #01`$Caractere_R1
        locus <- final_result_list[[R1_name]]$`EGF-like #01`$Position_Absolue_R1
    
    } else {
       colnames(heatmap_data) <- final_result_list[[R1_name]]$`EGF-like #02`$Caractere_R1
       locus <- final_result_list[[R1_name]]$`EGF-like #02`$Position_Absolue_R1
     
    }
    
    new_colnames <- add_suffix(colnames(heatmap_data))
    rownames(heatmap_data) <- row_names_except_current
    
    colnames(heatmap_data) = locus
    
    heatmap_data_car = heatmap_data
    
    
for (R2_name in row_names_except_current) {
    # Récupérer les scores depuis final_result_list
    scores <- final_result_list[[R1_name]][[R2_name]]$`AA de R1 score dans R2`
    
    # Récupérer les caractéristiques
    caractere_R2 <- final_result_list[[R1_name]][[R2_name]]$`Caractere_R2`
    
    # Trouver l'index de la ligne correspondant au R2_name dans la matrice
    row_index <- match(R2_name, row_names_except_current)
    
    # Assigner les scores à la ligne appropriée dans la matrice
    heatmap_data[row_index, ] <- scores
    heatmap_data_car[row_index, ] <- caractere_R2
    

}


# Convertir la matrice en un format long
heatmap_data_long <- melt(heatmap_data)
heatmap_data_car_long<- melt(heatmap_data_car)
merged_heatmap_data <- merge(heatmap_data_long, heatmap_data_car_long, by = c("Var1", "Var2"))




indices_a_marquer <- mutation_non_sens$Position
mutation_a_marquer <- data_frame("Position" =  mutation_non_sens$Position, "a.a" = mutation_non_sens$AA_substitue)


merged_heatmap_data$is_index_to_mark <- ifelse(merged_heatmap_data$Var2 %in% indices_a_marquer, TRUE, FALSE)
merged_heatmap_data$aa_patho <- ifelse(merged_heatmap_data$is_index_to_mark & 
                                           merged_heatmap_data$Var2 %in% mutation_a_marquer$Position,
                                       mutation_a_marquer$a.a[match(merged_heatmap_data$Var2, mutation_a_marquer$Position)],
                                       NA)


merged_heatmap_data$mutation_other_read <- ifelse(
  merged_heatmap_data$Var2 == mutation_a_marquer$Position  & 
  merged_heatmap_data$value.y == mutation_a_marquer$a.a,
  TRUE,
  FALSE
)

merged_heatmap_data <- merged_heatmap_data %>%
  arrange(Var2)
#Permet d'avoir les acides aminés 
colnames(heatmap_data) = new_colnames
heatmap_data_long2 = melt(heatmap_data)
merged_heatmap_data$Var2 = heatmap_data_long2$Var2



highlighted_data[[R1_name]] <- row.names(merged_heatmap_data[merged_heatmap_data$mutation_other_read == TRUE, ])
heatmap_datas [[R1_name]]<- merged_heatmap_data
# Plotting code
d_plot <- ggplot(merged_heatmap_data, aes(Var2, Var1)) +
  labs(x = R1_name, y = "Repeats") + 
  geom_tile(aes(fill = value.x), color = "black") +  # Ajout des cases de heatmap
  geom_text(aes(label = value.y, color = mutation_other_read), size = 3) +  # Ajout des valeurs de value.y avec couleur basée sur mutation_other_read
  geom_text(aes(label = value.y, color = is_index_to_mark), size = 3) +  # Ajout des valeurs de value.y avec couleur basée sur is_index_to_mark
  scale_fill_gradient2(low = "red", mid = "yellow", high = "white",
                       midpoint = -3, name = "selection pressure") +
  scale_color_manual(values = c("black", "blue"), guide = FALSE) +  # Couleurs des textes basées sur les colonnes ajoutées
  guides(fill = guide_legend(title = "selection pressure"),
         color = guide_legend(title = NULL, override.aes = list(size = 5))) +  # Personnalisation des légendes
  theme(legend.position = "bottom")  # Position de la légende

print(d_plot)

  cat("\n\n")
   cat("\n\n")





 }



    
```





### Heatmaps reciproque  {.tabset .tabset-fade}


Here, we look at the GEMME score of an amino acid in one of the repeats relative to the position of the repeat being examined.

```{r repeats_heatmaps_reciproque,  warning=FALSE, message=FALSE,fig.width=15,fig.height=15,results='asis'}



bornes = list() 
highlighted_data_rec = list()
heatmap_datas_rec = list()
# Boucle à travers chaque élément R1 de final_result_list
for (R1_name in names(final_result_list)) {
    cat("\n\n")
  cat("#### ",R1_name)
  cat("\n\n")
 

    results_list <- final_result_list[[R1_name]]
    
    if (R1_name == "EGF-like #02"){
        NCOL =  dim(final_result_list[[R1_name]]$`EGF-like #01`)[1]
    } else {
        NCOL =  dim(final_result_list[[R1_name]]$`EGF-like #02`)[1]
    }
    heatmap_data <- matrix(nrow = 3, ncol = NCOL)

    row_names_except_current <- setdiff(names(final_result_list), R1_name)
    
    if (R1_name == "EGF-like #02"){
        colnames(heatmap_data) <- final_result_list[[R1_name]]$`EGF-like #01`$Caractere_R1
        locus <- final_result_list[[R1_name]]$`EGF-like #01`$Position_Absolue_R1
    
    } else {
       colnames(heatmap_data) <- final_result_list[[R1_name]]$`EGF-like #02`$Caractere_R1
       locus <- final_result_list[[R1_name]]$`EGF-like #02`$Position_Absolue_R1
     
    }
    
    new_colnames <- add_suffix(colnames(heatmap_data))
    rownames(heatmap_data) <- row_names_except_current
    
    colnames(heatmap_data) = locus
    
    heatmap_data_car = heatmap_data
    
    
for (R2_name in row_names_except_current) {
    # Récupérer les scores depuis final_result_list
    scores <- final_result_list[[R1_name]][[R2_name]]$`AA de R2 score dans R1`
    
    # Récupérer les caractéristiques
    caractere_R2 <- final_result_list[[R1_name]][[R2_name]]$`Caractere_R2`
    
    # Trouver l'index de la ligne correspondant au R2_name dans la matrice
    row_index <- match(R2_name, row_names_except_current)
    
    # Assigner les scores à la ligne appropriée dans la matrice
    heatmap_data[row_index, ] <- scores
    heatmap_data_car[row_index, ] <- caractere_R2
    

}


# Convertir la matrice en un format long
heatmap_data_long <- melt(heatmap_data)
heatmap_data_car_long<- melt(heatmap_data_car)
merged_heatmap_data <- merge(heatmap_data_long, heatmap_data_car_long, by = c("Var1", "Var2"))


# Supposons que 'mutations_non_sens$Position' est un vecteur d'indices à marquer
indices_a_marquer <- mutation_non_sens$Position
mutation_a_marquer <- data_frame("Position" =  mutation_non_sens$Position, "a.a" = mutation_non_sens$AA_substitue)

# Ajouter une colonne pour vérifier si l'indice est dans 'indices_a_marquer'
merged_heatmap_data$is_index_to_mark <- ifelse(merged_heatmap_data$Var2 %in% indices_a_marquer, TRUE, FALSE)
merged_heatmap_data$mutation_other_read <- ifelse(
  merged_heatmap_data$Var2 == mutation_a_marquer$Position & 
  merged_heatmap_data$value.y == mutation_a_marquer$a.a,
  TRUE,
  FALSE
)

merged_heatmap_data <- merged_heatmap_data %>%
  arrange(Var2)
#Permet d'avoir les acides aminés 
colnames(heatmap_data) = new_colnames
heatmap_data_long2 = melt(heatmap_data)
merged_heatmap_data$Var2 = heatmap_data_long2$Var2



highlighted_data_rec[[R1_name]] <- row.names(merged_heatmap_data[merged_heatmap_data$mutation_other_read == TRUE, ])
heatmap_datas_rec[[R1_name]]<- merged_heatmap_data
# Plotting code
d_plot <- ggplot(merged_heatmap_data, aes(Var2, Var1)) +
  labs(x = R1_name, y = "Repeats") + 
  geom_tile(aes(fill = value.x), color = "black") +  # Ajout des cases de heatmap
  geom_text(aes(label = value.y, color = mutation_other_read), size = 3) +  # Ajout des valeurs de value.y avec couleur basée sur mutation_other_read
  geom_text(aes(label = value.y, color = is_index_to_mark), size = 3) +  # Ajout des valeurs de value.y avec couleur basée sur is_index_to_mark
  scale_fill_gradient2(low = "red", mid = "yellow", high = "white",
                       midpoint = -3, name = "selection pressure") +
  scale_color_manual(values = c("black", "blue"), guide = FALSE) +  # Couleurs des textes basées sur les colonnes ajoutées
  guides(fill = guide_legend(title = "selection pressure"),
         color = guide_legend(title = NULL, override.aes = list(size = 5))) +  # Personnalisation des légendes
  theme(legend.position = "bottom")  # Position de la légende

print(d_plot)


cat("\n\n")
cat("\n\n")




 }


cat("\n\n")
    
```
### Heatmaps mutated {.tabset .tabset-fade}

Same as the first heatmap but instead of the WT it is the mutated sequence 


```{r repeats_heatmaps_mutated,  warning=FALSE, message=FALSE,fig.width=15,fig.height=15,results='asis'}



bornes = list() 
highlighted_data_mutated = list()
heatmap_datas_mutated = list()
# Boucle à travers chaque élément R1 de final_result_list_mutated
for (R1_name in names(final_result_list_mutated)) {
    cat("\n\n")
  cat("#### ",R1_name)
  cat("\n\n")

    results_list <- final_result_list_mutated[[R1_name]]
    
    if (R1_name == "cb EGF-like #02"){
        NCOL =  dim(final_result_list_mutated[[R1_name]]$`EGF-like #01`)[1]
    } else {
        NCOL =  dim(final_result_list_mutated[[R1_name]]$`EGF-like #02`)[1]
    }
    heatmap_data <- matrix(nrow = 42, ncol = NCOL)

    row_names_except_current <- setdiff(names(final_result_list_mutated), R1_name)
    
    if (R1_name == "cb EGF-like #02"){
        colnames(heatmap_data) <- final_result_list_mutated[[R1_name]]$`EGF-like #01`$Caractere_R1
        locus <- final_result_list_mutated[[R1_name]]$`EGF-like #01`$Position_Absolue_R1
    
    } else {
       colnames(heatmap_data) <- final_result_list_mutated[[R1_name]]$`EGF-like #02`$Caractere_R1
       locus <- final_result_list_mutated[[R1_name]]$`EGF-like #02`$Position_Absolue_R1
     
    }
    
    new_colnames <- add_suffix(colnames(heatmap_data))
    rownames(heatmap_data) <- row_names_except_current
    
    colnames(heatmap_data) = locus
    
    heatmap_data_car = heatmap_data
    
    
for (R2_name in row_names_except_current) {
    # Récupérer les scores depuis final_result_list_mutated
    scores <- final_result_list_mutated[[R1_name]][[R2_name]]$`AA de R1 score dans R2`
    
    # Récupérer les caractéristiques
    caractere_R2 <- final_result_list_mutated[[R1_name]][[R2_name]]$`Caractere_R2`
    
    # Trouver l'index de la ligne correspondant au R2_name dans la matrice
    row_index <- match(R2_name, row_names_except_current)
    
    # Assigner les scores à la ligne appropriée dans la matrice
    heatmap_data[row_index, ] <- scores
    heatmap_data_car[row_index, ] <- caractere_R2
    

}


# Convertir la matrice en un format long
heatmap_data_long <- melt(heatmap_data)
heatmap_data_car_long<- melt(heatmap_data_car)
merged_heatmap_data <- merge(heatmap_data_long, heatmap_data_car_long, by = c("Var1", "Var2"))



indices_a_marquer <- mutation_non_sens$Position
mutation_a_marquer <- data_frame("Position" =  mutation_non_sens$Position, "a.a" = mutation_non_sens$AA_substitue)


merged_heatmap_data$is_index_to_mark <- ifelse(merged_heatmap_data$Var2 %in% indices_a_marquer, TRUE, FALSE)

merged_heatmap_data$mutation_other_read <- ifelse(
  merged_heatmap_data$Var2 == mutation_a_marquer$Position & 
  merged_heatmap_data$value.y == mutation_a_marquer$a.a,
  TRUE,
  FALSE
)

merged_heatmap_data <- merged_heatmap_data %>%
  arrange(Var2)
#Permet d'avoir les acides aminés 
colnames(heatmap_data) = new_colnames
heatmap_data_long2 = melt(heatmap_data)
merged_heatmap_data$Var2 = heatmap_data_long2$Var2



highlighted_data_mutated[[R1_name]] <- row.names(merged_heatmap_data[merged_heatmap_data$mutation_other_read == TRUE, ])
heatmap_datas_mutated[[R1_name]]<- merged_heatmap_data
# Plotting code
d_plot <- ggplot(merged_heatmap_data, aes(Var2, Var1)) +
  labs(x = R1_name, y = "Repeats") + 
  geom_tile(aes(fill = value.x), color = "black") +  # Ajout des cases de heatmap
  geom_text(aes(label = value.y, color = mutation_other_read), size = 3) +  # Ajout des valeurs de value.y avec couleur basée sur mutation_other_read
  geom_text(aes(label = value.y, color = is_index_to_mark), size = 3) +  # Ajout des valeurs de value.y avec couleur basée sur is_index_to_mark
  scale_fill_gradient2(low = "red", mid = "yellow", high = "white",
                       midpoint = -3, name = "selection pressure") +
  scale_color_manual(values = c("black", "blue"), guide = FALSE) +  # Couleurs des textes basées sur les colonnes ajoutées
  guides(fill = guide_legend(title = "selection pressure"),
         color = guide_legend(title = NULL, override.aes = list(size = 5))) +  # Personnalisation des légendes
  theme(legend.position = "bottom")  # Position de la légende

print(d_plot)





  cat("\n\n")
   cat("\n\n")

 }



    
```

### Logos  {.tabset .tabset-fade}

Here we have for each CB EGF-like repeat, 3 logos. 

The first one represents the heatmap of the repeat being observed versus the others. In summary, the larger the letter, the higher its average selection pressure score is with a threshold (see below). In other words, the larger the letter, the more it is 'forbidden' in the dimensions of CB EGF-like. For the third logo, it's exactly the same principle, but the WT sequence of the repeat is replaced by the sequence with the mutated amino acids (if two substituting AAs are found, then only one of the two is chosen). 

The second logo is a score given for the most allowed amino acids at the position of the observed repeat. It relies more on the green matrices mentioned earlier in this report. The calculation for the allowed score is as follows:

\[ \text{letter\_size\_pow100} = 10 \times \text{letter\_size} \]

Where \(\text{letter\_size}\) is determined by the condition:

\[ \begin{cases}
\max(\text{abs\_Value\_log}) + 1 & \text{if } \text{abs\_Value} = 0 \\
\max(\text{abs\_Value\_log}) - \text{abs\_Value\_log} + 1 & \text{otherwise}
\end{cases} \]

And \(\text{abs\_Value\_log}\) is calculated as:

\[ \text{abs\_Value\_log} = \log(\text{abs\_Value} + 1) \]


```{r Logo,  warning=FALSE, message=FALSE, fig.width=20 ,fig.height=5, results= 'asis'}
cat("treshold for Logo of forbidden aa : ",treshold)
PCA_data_long <- read.csv("PCA_data_long.csv")
all_gemme_add_mutated_list <- list()
all_gemme_add_list <- list()
Scores <- list()
for (R1_name in names(final_result_list)) {
  cat("\n\n")
  cat("#### ",R1_name)
  cat("\n\n")

   
  
  
  debut_R1 <- as.integer(get_debut_for_name(R1_name, selected_structures))
  end_R1 <- as.integer(get_end_for_name(R1_name, selected_structures))
  intervalle <- c(debut_R1, end_R1)
  bornes[[R1_name]] <- intervalle
  numeros_lignes <- seq.int(debut_R1, end_R1)
  # Plot 1 : ggplot pour data_filtre
  data_filtre <- data_long_ori %>%
    filter(ColumnNames >= debut_R1 & ColumnNames <= end_R1) %>%
    replace_na(list(Value = 0)) %>%
    mutate(abs_Value = abs(Value),
           abs_Value_log = log(abs_Value + 1),
           letter_size = ifelse(abs_Value == 0, max(abs_Value_log) + 1, max(abs_Value_log) - abs_Value_log + 1),
           letter_size_pow100 = 10 ^ letter_size) 
  
  
  
  
## Biochemic info 
data(sequences)
acides_amines_dict <- unique(ggfortify(sequences, peptide, treatment = class)[, c("element", "Polarity", "Water")])
data_filtre$AA <- toupper(data_filtre$RowNames)
data_filtre <- merge(data_filtre, acides_amines_dict, by.x = "AA", by.y = "element", all.x = TRUE)
  
  plot <- ggplot(data = data_filtre) + 
    geom_logo(aes(x = ColumnNames, y = letter_size_pow100, label = AA, fill = interaction(Polarity, Water)),
              alpha = 0.6, position = "fill", color = "transparent")  +
    labs(x =" ", y = "Allowed") +
    scale_x_continuous(breaks = numeros_lignes) +
        theme(plot.title = element_text(size = 100),
          plot.subtitle = element_text(size = 40), 
          plot.caption = element_text(size = 100), 
          axis.title = element_text(size = 10)) 
  
  # Plot 2 : ggplot pour Gemme_add
activation = 4


Gemme_add <- heatmap_datas[[R1_name]] %>%
  group_by(Var2) %>%
  summarize(
    total_count = n(),  
    Somme_value_x_abs = mean(abs(value.x), na.rm = TRUE),
    score = sum(abs(value.x) > activation, na.rm = TRUE) / n() 
  ) %>%
  mutate(
    AA = gsub("[^[:alpha:]]", "", Var2),
    Numero_ligne = numeros_lignes
  )

# Traitement initial pour Gemme_add_mutated
Gemme_add_mutated <- heatmap_datas_mutated[[R1_name]] %>%
  group_by(Var2) %>%
  summarize(
    total_count = n(),  
    Somme_value_x_abs = mean(abs(value.x), na.rm = TRUE),
    score = sum(abs(value.x) > activation, na.rm = TRUE) / n() 
  ) %>%
  mutate(
    AA = gsub("[^[:alpha:]]", "", Var2),
    Numero_ligne = numeros_lignes
  )

combined_df <- left_join(Gemme_add, Gemme_add_mutated, by = "Numero_ligne", suffix = c("_WT", "_mutated"))

# Sélection des colonnes spécifiques pour le tableau final
combined_df <- combined_df %>%
  mutate(ratio_score = score_mutated / score_WT) %>%
  select(Numero_ligne, AA_WT, AA_mutated, score_WT, score_mutated, ratio_score)
colnames(combined_df)[colnames(combined_df) == "Numero_ligne"] <- "Position"



Gemme_add <- Gemme_add %>%
  mutate(Somme_value_x_abs = ifelse(Somme_value_x_abs < treshold, 0, Somme_value_x_abs))
Gemme_add_mutated <- Gemme_add_mutated %>%
  mutate(Somme_value_x_abs = ifelse(Somme_value_x_abs < treshold, 0, Somme_value_x_abs))




## Biochemic info 
acides_amines_dict <- unique(ggfortify(sequences, peptide, treatment = class)[, c("element", "Polarity", "Water")])
Gemme_add$AA <- toupper(Gemme_add$AA)
Gemme_add_mutated$AA <- toupper(Gemme_add_mutated$AA)
Gemme_add <- merge(Gemme_add, acides_amines_dict, by.x = "AA", by.y = "element", all.x = TRUE)
Gemme_add_mutated <- merge(Gemme_add_mutated, acides_amines_dict, by.x = "AA", by.y = "element", all.x = TRUE)



  
  plot_logo <- ggplot(data = Gemme_add ) +
    geom_logo(aes(x = Numero_ligne, y = Somme_value_x_abs, label = AA, fill = interaction(Polarity, Water)),alpha = 0.6,position = "classic",color="transparent") +
    labs(x =" ",y = "Forbidden")     +
    scale_x_continuous(breaks = numeros_lignes) + theme(legend.position = "none") +     scale_x_continuous(breaks = numeros_lignes) +
        theme(plot.title = element_text(size = 40),
          plot.subtitle = element_text(size = 40), 
          plot.caption = element_text(size = 40), 
          axis.title = element_text(size = 10)) 
  
  plot_mut <- ggplot(data = Gemme_add_mutated ) +
    geom_logo(aes(x = Numero_ligne, y = Somme_value_x_abs, label = AA, fill = interaction(Polarity, Water)),alpha = 0.6,position = "classic",color="transparent") +
    labs(x = paste("sequence",R1_name), y = "Forbidden pathogen")   +
    scale_x_continuous(breaks = numeros_lignes) + theme(legend.position = "none") +     scale_x_continuous(breaks = numeros_lignes) +
        theme(plot.title = element_text(size = 40),
          plot.subtitle = element_text(size = 40), 
          plot.caption = element_text(size = 40), 
          axis.title = element_text(size = 10)) 
  
  
  # Combinaison des deux graphiques et ajustements
  combined_plot <- plot_logo + plot + plot_mut + plot_layout(nrow = 3, heights = c(1, 3))  # 
  
  # Afficher le graphique combiné
  print(combined_plot)
  
 
all_gemme_add_list[[R1_name]] <- Gemme_add
all_gemme_add_mutated_list[[R1_name]] <- Gemme_add_mutated
Scores[[R1_name]] = combined_df 
  cat("\n\n")
   cat("\n\n")
}



All_Gemme_add <- bind_rows(all_gemme_add_list)
All_Gemme_add_mutated <- bind_rows(all_gemme_add_mutated_list) 
All_Gemme_add_combined <- bind_rows(All_Gemme_add, All_Gemme_add_mutated)
All_Gemme_add_combined <- All_Gemme_add_combined %>%
  distinct(AA, Numero_ligne, .keep_all = TRUE)

score <- bind_rows(Scores)
All_Gemme_add_combined <- All_Gemme_add_combined %>%
  mutate(
    Var2 = substr(Var2, 1, 1)
    
  )

PCA_data_long <- PCA_data_long %>%
  left_join(All_Gemme_add_combined, by = c("AA_substitue" = "Var2", "Position" = "Numero_ligne"))
PCA_data_long <- PCA_data_long[, !names(PCA_data_long) %in% c("Var2", "Polarity_mutated", "Water_mutated")]
PCA_data_long <- PCA_data_long %>%
  select(-AA_substitue)



write.csv(score, "scores_EGF_like.csv", row.names = FALSE)
write.csv(PCA_data_long, "PCA_data_long.csv", row.names = FALSE)


```





