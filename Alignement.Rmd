---
title: " Alignement "
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: hide
    highlight: espresso
    theme: yeti
    toc: yes
    toc_depth: 3
    toc_float: yes
---

```{r PARAM, include=FALSE}


SEUIL = -6.5

scape_gap = TRUE 

INTERVALLE = c(1700,1750)

mutation_pathogene = "non" #patho, div or non 




```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

```{r library,  message=FALSE,fig.width=10,fig.height=6,warning=FALSE}

library(ggplot2)
library(knitr)
library(rmarkdown)
library(stringr)
library(tidyverse)
library(reshape2)
library(heatmaply)
library(Biostrings)
library(openxlsx)
library(readxl)
library(gridExtra)
library(patchwork)
library(ggnewscale)
library(RColorBrewer)
library(msa)
library(cowplot)

 theme_set( theme_classic())



```

```{r Datas,  warning=FALSE, message=FALSE}

cat("Threshold for EvolCombi:", SEUIL, "| Truncate sequence for gaps in the WT?:", scape_gap)
cat("type of mutation studied here :", mutation_pathogene)



#PATH ##########################################################################

path_prot = "./FBN1/P35555/"               #chemin relatif  
path_thoraxe = "./FBN1/thoraxe/"
path_phylosof = paste0(path_thoraxe,"phylosofs/")
path_msa = paste0(path_thoraxe,"msa/")

# DATA #########################################################################
Conservation = read.table(paste0(path_prot,"P35555_conservation.txt"))
EvolCombi = read.table(paste0(path_prot,"P35555_normPred_evolCombi.txt"))
EvolEpi = read.table(paste0(path_prot,"P35555_normPred_evolEpi.txt"))
EvolInd = read.table(paste0(path_prot,"P35555_normPred_evolInd.txt"))

Ases_table = read.csv(paste0(path_thoraxe,"ases_table.csv"))
Path_table = read.csv(paste0(path_thoraxe,"path_table.csv"))
s_exon = read.csv(paste0(path_thoraxe,"s_exon_table.csv"))
transcripts_pir = readLines(paste0(path_phylosof,"transcripts.pir"))


#######prot #####################################################################
fichier_fasta <- paste0(path_prot,"P35555.FASTA")
lines <- readLines(fichier_fasta)

sequence_dict <- list()

current_seq_name <- ""
current_seq <- character()
 
for (line in lines) {
  if (startsWith(line, ">")) {
    if (current_seq_name != "") {
      sequence_dict[[current_seq_name]] <- paste(current_seq, collapse = "")
    }
    current_seq_name <- substr(line, 2, nchar(line))
    current_seq <- character()  
  } else {
    current_seq <- c(current_seq, line)
  }
}

# Enregistrez la dernière séquence
if (current_seq_name != "") {
  sequence_dict[[current_seq_name]] <- paste(current_seq, collapse = "")
}

P35555 = sequence_dict$P35555


file_path <- "./FBN1/FBN1stru.xls"

sheet_names <- excel_sheets(file_path)

# Charger les données de chaque feuille dans une liste
FBN1_structure <- lapply(sheet_names, function(sheet) {
  read_excel(file_path, sheet = sheet)
})
mutation_tb5 = FBN1_structure[[2]]
colnames(mutation_tb5) <- c("Mutation", "Phénotype")
mutation_tb5 <- mutation_tb5 %>% filter(!is.na(Mutation) & !grepl("Variation", Mutation))
mutation_tb5 <- mutation_tb5 %>% mutate(
  AA_de_base = str_extract(Mutation, "[A-Z][a-z]*"),
  Position = str_extract(Mutation, "\\d+"),
  AA_substitue = str_extract(Mutation, "[A-Z][a-z]*$")
)

mutation_mfs = FBN1_structure[[3]]
colnames(mutation_mfs) <- c("1","2","3","4","Mutation","Phénotype" )
mutation_mfs<- mutation_mfs %>% filter(!is.na(Mutation) & !grepl("Variation", Mutation))
mutation_mfs <- mutation_mfs %>% mutate(
  AA_de_base = str_extract(Mutation, "[A-Z][a-z]*"),
  Position = str_extract(Mutation, "\\d+"),
  AA_substitue = str_extract(Mutation, "[A-Z][a-z]*$")
)


mutation_probable = FBN1_structure[[6]]
colnames(mutation_probable) <- c("Mutation","c.")
mutation_probable<- mutation_probable %>% filter(!is.na(Mutation) & !grepl("Variation", Mutation))
mutation_probable <- mutation_probable %>% mutate(
  AA_de_base = str_extract(Mutation, "[A-Z][a-z]*"),
  Position = str_extract(Mutation, "\\d+"),
  AA_substitue = str_extract(Mutation, "[A-Z][a-z]*$")
)
mutation_probable$classe <- 0  
# Trouve les indices où chaque classe apparaît dans la colonne "Mutation"
classes <- unique(mutation_probable$Mutation[grep("^Classe", mutation_probable$Mutation)])
for (classe in classes) {
  classe_indices <- which(mutation_probable$Mutation == classe)
  
  # Attribue la valeur correspondante à la nouvelle colonne pour les lignes en dessous de chaque classe
  if (length(classe_indices) > 0) {
    mutation_probable$classe[(classe_indices[1] + 1):nrow(mutation_probable)] <- (gsub("^Classe ", "", classe))
  }
}
mutation_probable <- mutation_probable %>% filter(!grepl("^Classe", Mutation))


mutation_non_sens = FBN1_structure[[4]]
mutation_non_sens<- mutation_non_sens[,c("p.","Clinique","Néomutation?","Cardio","Ophtalmo","Pneumothorax","cutané","neuro","Sévère ou jeune")]
mutation_non_sens <- mutation_non_sens %>%
  mutate(
    AA_de_base = str_extract(p., "[A-Z][a-z]*"),
    Position = as.integer(str_extract(p., "\\d+")), # Convertir la position en entier
    AA_substitue = str_extract(p., "[A-Z][a-z]*$"),
    Clinique = str_extract(Clinique, "^[A-Za-z]+"),

    

  )

correspondance <- data.frame(
  AA_3_lettres = c("Ala", "Arg", "Asn", "Asp", "Cys", "Gln", "Glu", "Gly", "His", "Ile", "Leu", "Lys", "Met", "Phe", "Pro", "Ser", "Thr", "Trp", "Tyr", "Val","A", "R", "N", "D", "C", "Q", "E", "G", "H", "I", "L", "K", "M", "F", "P", "S", "T", "W", "Y", "V"),
  AA_1_lettre = c("a", "r", "n", "d", "c", "q", "e", "g", "h", "i", "l", "k", "m", "f", "p", "s", "t", "w", "y", "v","a", "r", "n", "d", "c", "q", "e", "g", "h", "i", "l", "k", "m", "f", "p", "s", "t", "w", "y", "v")
)



# Joindre la table de correspondance pour convertir les notations en trois lettres en une lettre
mutation_tb5 <- mutation_tb5 %>%
  left_join(correspondance, by = c("AA_de_base" = "AA_3_lettres")) %>%
  left_join(correspondance, by = c("AA_substitue" = "AA_3_lettres"))


mutation_mfs <- mutation_mfs %>%
  left_join(correspondance, by = c("AA_de_base" = "AA_3_lettres")) %>%
  left_join(correspondance, by = c("AA_substitue" = "AA_3_lettres"))

mutation_probable <- mutation_probable %>%
  left_join(correspondance, by = c("AA_de_base" = "AA_3_lettres")) %>%
  left_join(correspondance, by = c("AA_substitue" = "AA_3_lettres")) 

mutation_non_sens = mutation_non_sens %>%
  left_join(correspondance, by = c("AA_de_base" = "AA_3_lettres")) %>%
  left_join(correspondance, by = c("AA_substitue" = "AA_3_lettres")) 


# Sélectionner uniquement les colonnes nécessaires et renommer
mutation_tb5 <- mutation_tb5 %>% 
  select(Mutation, Phénotype, AA_de_base = AA_1_lettre.x, Position, AA_substitue = AA_1_lettre.y) %>% select(AA_de_base, Position, AA_substitue)

mutation_mfs <- mutation_mfs %>% 
  select(Mutation, Phénotype, AA_de_base = AA_1_lettre.x, Position, AA_substitue = AA_1_lettre.y) %>% select(AA_de_base, Position, AA_substitue)

mutation_probable <- mutation_probable %>% 
  select(Mutation, AA_de_base = AA_1_lettre.x, Position, AA_substitue = AA_1_lettre.y, classe) %>% select(AA_de_base, Position, AA_substitue,classe)

mutation_non_sens = mutation_non_sens %>% select(Clinique, AA_de_base = AA_1_lettre.x, Position, AA_substitue = AA_1_lettre.y,"Néomutation?","Cardio","Ophtalmo","Pneumothorax","cutané","neuro","Sévère ou jeune") %>% select(AA_de_base, Position, AA_substitue,Clinique,"Néomutation?","Cardio","Ophtalmo","Pneumothorax","cutané","neuro","Sévère ou jeune") %>% 
  filter(!is.na(AA_de_base))

                                                                                                                                                         




mutation_tb5 = data.frame(mutation_tb5)
mutation_mfs = data.frame(mutation_mfs)
mutation_probable = data.frame(mutation_probable)
mutation_non_sens = data.frame(mutation_non_sens)

mutation <- rbind(mutation_tb5, mutation_mfs)




########## s_exons/msa ##########################################################
fasta_files <- list.files(path_msa, pattern = ".fasta$", full.names = TRUE)

fasta_data <- data.frame(Nom_Fichier = character(0), Sequence = character(0), stringsAsFactors = FALSE)

for (fasta_file in fasta_files) {
  fasta_content <- readLines(fasta_file)
  title <- fasta_content[1]
  sequence <- paste(fasta_content, collapse = "")  # Combinez toutes les lignes de séquence

  fasta_data <- rbind(fasta_data, data.frame(Nom_Fichier = basename(fasta_file), Sequence = sequence, stringsAsFactors = FALSE))
}

#En temps normal essayer de le généraliser en le trouvant par exepression régulière dans le .PIR 
transcriptID_WT = "ENST00000316623"

cat("Here WT sequence transcript is computed by MEGA software | Transcript : ", transcriptID_WT ) 


row_index <- which(Path_table$TranscriptIDCluster == transcriptID_WT)

if (length(row_index) == 0) {
  break 
} else {
  path_WT <- Path_table$Path[row_index]

}


 # Convertir le chemin path_WT en vecteur d'éléments
path_elements <- unlist(strsplit(path_WT, "/"))

# Créer un vecteur de noms de fichiers correspondant à chaque élément du chemin
file_names <- paste0("msa_s_exon_", path_elements, ".fasta")

# Subset fasta_data en fonction de l'ordre des fichiers
subset_fasta_data <- fasta_data[fasta_data$Nom_Fichier %in% file_names, ]

# Diviser la colonne "Sequence" en plusieurs colonnes
seq_list <- strsplit(subset_fasta_data$Sequence, ">")

for (i in 1:length(seq_list)) {
  seqs <- seq_list[[i]]
  for (j in 1:length(seqs)) {
    seqs[j] <- gsub(".*([0-9])", "", seqs[j])
  }
  seq_list[[i]] <- seqs
}

# Créer une nouvelle liste pour stocker les séquences exon par exon
exon_sequences_list <- list()

# Parcourir seq_list et diviser en séquences exon par exon
for (i in 1:length(seq_list)) {
  seqs <- seq_list[[i]]
  exon_sequences_list[[i]] <- unlist(strsplit(seqs, ">"))
}

# Trouver la longueur maximale des listes de séquences exon par exon
max_length <- max(sapply(exon_sequences_list, length))

# Assurer que toutes les listes de séquences ont la même longueur
for (i in 1:length(exon_sequences_list)) {
  if (length(exon_sequences_list[[i]]) < max_length) {
    diff_length <- max_length - length(exon_sequences_list[[i]])
    exon_sequences_list[[i]] <- c(exon_sequences_list[[i]], rep(NA, diff_length))
  }
}

# Créer un nouveau dataframe avec les séquences exon par exon
new_fasta_data <- data.frame(Nom_Fichier = subset_fasta_data$Nom_Fichier)
for (i in 1:max_length) {
  column_name <- paste("Exon", i, sep = "_")
  new_fasta_data[[column_name]] <- sapply(exon_sequences_list, function(x) x[i])
}



# Obtenez l'ordre des noms de fichiers dans le dataframe actuel
order_in_fasta_data <- match(file_names, new_fasta_data$Nom_Fichier)

# Réorganisez les lignes du dataframe en fonction de l'ordre obtenu
new_fasta_data <- new_fasta_data[order_in_fasta_data, ]

# Réinitialisez les indices des lignes du dataframe pour qu'ils soient consécutifs
row.names(new_fasta_data) <- NULL


# Supprimer start and stop
new_fasta_data <- new_fasta_data[-c(1, nrow(new_fasta_data)), ]

# Supprimer la première colonne NomFichier
new_fasta_data <- new_fasta_data[, -1]

new_fasta_data <- as.data.frame(lapply(new_fasta_data, tolower))

if (scape_gap) {

# Fonction pour aligner les séquences en supprimant les acides aminés correspondants aux gaps dans la première séquence
aligner_sequences <- function(seq, reference) {
  seq_alignee <- ""
  for (i in 1:nchar(reference)) {
    if (substr(reference, i, i) != "-") {
      seq_alignee <- paste0(seq_alignee, substr(seq, 1, 1))
      seq <- substr(seq, 2, nchar(seq))
    }
    else {
      seq <- substr(seq, 2, nchar(seq))
    }
  }
  return(seq_alignee)
}

for (MSA in rownames(new_fasta_data)) {
  reference <- new_fasta_data[MSA, "Exon_1"]
  sequences_alignees <- lapply(new_fasta_data[MSA, ], aligner_sequences, reference = reference)
  new_fasta_data[MSA, ] <- sequences_alignees
}

new_fasta_data <- new_fasta_data %>%
  mutate_all(~ifelse(substr(., 1, 1) == "N", NA, .))

}



# Créez une matrice vide pour stocker les résultats
result_matrix <- matrix(0, nrow = 0, ncol = 26)

# Parcourez chaque ligne de new_fasta_data
for (i in 1:nrow(new_fasta_data)) {
  sequences <- new_fasta_data[i,]
  position_counts <- matrix(0, nrow = nchar(sequences[[1]]), ncol = 26)
  
  # Comptez les acides aminés à chaque position
  for (j in 1:nchar(sequences[[1]])) {
    position <- substr(sequences, j, j)
    counts <- table(position)
    position_counts[j, ] <- counts[letters]
  }
  
  # Ajoutez les résultats à la matrice résultante
  result_matrix <- rbind(result_matrix, position_counts)
}

# Réinitialisez les noms de colonnes et de lignes
colnames(result_matrix) <- letters
rownames(result_matrix) <- 1:nrow(result_matrix)


# Convertir la matrice en un data frame long
data_longMSA <- as.data.frame(result_matrix)

# Ajouter une colonne pour la position
data_longMSA <- data_longMSA %>%
  mutate(Position = row_number())

# Renommer les colonnes en fonction des acides aminés
data_longMSA <- data_longMSA %>%
  pivot_longer(cols = -Position, names_to = "Acide_aminé", values_to = "Compte")

# Remplacer les NA par des 0
data_longMSA[is.na(data_longMSA$Compte), "Compte"] <- 0

names(data_longMSA) = c("ColumnNames","RowNames","Value")



##### Pour les séquences genomiques #########

# Supprimer les colonnes inutiles
FBN1_structure_cleaned <- FBN1_structure[[1]] %>%
  select(`n°aa`, aa, Structure)

# Fusionner avec la table de correspondance
FBN1_structure_cleaned <- merge(FBN1_structure_cleaned, correspondance, by.x = "aa", by.y = "AA_3_lettres", all.x = TRUE)

# Trier par le numéro d'acide aminé
FBN1_structure_cleaned <- FBN1_structure_cleaned[order(FBN1_structure_cleaned$`n°aa`), ]

# Créer la nouvelle table
Table_seq <- FBN1_structure_cleaned %>%
  group_by(`Structure`) %>%
  summarize(
    Sequence_AA = paste(AA_1_lettre[order(`n°aa`)], collapse = ""),
    Debut_Fin = paste(min(`n°aa`), max(`n°aa`), sep = ";"),
    Longueur = nchar(Sequence_AA)
  )


```

\

#### R

This feature allows you to display the version of the programming language used (configurable).

```{r runInfo_r,  message=FALSE}
# print( sessionInfo());

```

### 1/ Alignments and threshold {.tabset .tabset-fade}

Here, in order to visualize certain amino acids that are more deleterious than others (calculated using GEMME), we set a threshold (configurable), below which amino acids are considered non-deleterious (gray), and above which they are considered deleterious (red). Additionally, dark gray represents the wild-type (WT) amino acids, and in blue, the WT amino acids that have pathogenic deletions according to information from Bichat Hospital. In green, the amino acids are marked as pathogenic if they are present in the sequence (per Bichat Hospital's data). Finally, in purple, the color indicates the presence of both green and red, signifying amino acids that are both deleterious (according to GEMME) and pathogenic (per Bichat Hospital's data).

The top histogram allows us to visualize the average impact score (deleterious or non-deleterious) by position.

The lower histogram, on the other hand, displays the evolutionary conservation by position.

The second tab allows for zooming in on a selected sequence (configurable).

#### General view of the protein

```{r heatmaps,  message=FALSE,fig.width=10,fig.height=10,warning=FALSE}

### Hist ####################################################################

EvolCombi_matrix <- as.matrix(EvolCombi)

for (col in 1:ncol(EvolCombi_matrix)) {
  col_mean <- mean(EvolCombi_matrix[, col], na.rm = TRUE)  
  EvolCombi_matrix[is.na(EvolCombi_matrix[, col]), col] <- col_mean
}

col_means_Combi <- colMeans(EvolCombi_matrix)


mean_data <- data.frame(Index = 1:length(col_means_Combi), Mean = col_means_Combi)

histogram <- ggplot(mean_data, aes(x = Index, y = Mean)) +
  geom_bar(stat = "identity", fill = "blue") +
  labs(title = "Histogramme des Moyennes EvolCombi par colonne", x = "Index a.a", y = "Moyenne EvolCombi") +
    geom_hline(yintercept = SEUIL, color = "red", linetype = "dashed", size = 1) +
  annotate("text", x = 1, y = SEUIL + 0.2, label = paste("SEUIL =", SEUIL), color = "red")

###############################################################################
data <- EvolCombi

matrice1 <- FBN1_structure[[1]]
indices_lignes_non_na <- !is.na(matrice1$`Régions particulières`)
noms_de_lignes <- matrice1$`Régions particulières`[indices_lignes_non_na]
numeros_de_lignes <- matrice1$`n°aa`[indices_lignes_non_na]
régions <- data.frame(NomDeLigne = noms_de_lignes, NumeroDeLigne = numeros_de_lignes)

seuil <- SEUIL
binary_matrix <- apply(EvolCombi, MARGIN = c(1, 2), FUN = function(x) ifelse(x > seuil, 0, 1))

rownames(binary_matrix) <- rownames(data)



data_df <- as.data.frame(binary_matrix)
data_df$RowNames <- rownames(data_df)  

data_long <- reshape2::melt(data_df, id.vars = "RowNames")
colnames(data_long) <- c("RowNames", "ColumnNames", "Value")
data_long$ColumnNames <- as.numeric(data_long$ColumnNames)


regions_indices <- which(!is.na(matrice1$`Régions particulières`))



if (mutation_pathogene == "patho"){
for (i in 1:nrow(mutation)) {
  # Récupérer la position, la lettre de base et la lettre substituée
  position <- mutation$Position[i]
  lettre_base <- mutation$AA_de_base[i]
  lettre_substituee <- mutation$AA_substitue[i]
  
  # Trouver l'indice correspondant dans data_long
  index <- which(data_long$ColumnNames == position)
  
    
   if (!is.na(lettre_substituee)) {
    if (data_long$Value[index[data_long$RowNames[index] == lettre_substituee]] == 1) {
      data_long$Value[index[data_long$RowNames[index] == lettre_substituee]] <- 4} else {
        data_long$Value[index[data_long$RowNames[index] == lettre_substituee]] <- 2}
   }  else {data_long$Value[index[data_long$RowNames[index] == lettre_base]] <- 3
    }
}} 
if (mutation_pathogene == "div") {
for (i in 1:nrow(mutation_probable)) {
  # Récupérer la position, la lettre de base et la lettre substituée
  position <- mutation_probable$Position[i]
  lettre_base <- mutation_probable$AA_de_base[i]
  lettre_substituee <- mutation_probable$AA_substitue[i]
  
  # Trouver l'indice correspondant dans data_long
  index <- which(data_long$ColumnNames == position)
  
    
   if (!is.na(lettre_substituee)) {
    if (data_long$Value[index[data_long$RowNames[index] == lettre_substituee]] == 1) {
      data_long$Value[index[data_long$RowNames[index] == lettre_substituee]] <- 4} else {
        data_long$Value[index[data_long$RowNames[index] == lettre_substituee]] <- 2}
   }  else {data_long$Value[index[data_long$RowNames[index] == lettre_base]] <- 3
    }
}}


if (mutation_pathogene == "non") {
  for (i in 1:nrow(mutation_non_sens)) {
  # Récupérer la position, la lettre de base et la lettre substituée
  position <- mutation_non_sens$Position[i]
  lettre_base <- mutation_non_sens$AA_de_base[i]
  lettre_substituee <- mutation_non_sens$AA_substitue[i]
  
  # Trouver l'indice correspondant dans data_long
  index <- which(data_long$ColumnNames == position)
  
    
   if (!is.na(lettre_substituee)) {
    if (data_long$Value[index[data_long$RowNames[index] == lettre_substituee]] == 1) {
      data_long$Value[index[data_long$RowNames[index] == lettre_substituee]] <- 4} else {
        data_long$Value[index[data_long$RowNames[index] == lettre_substituee]] <- 2}
   }  else {data_long$Value[index[data_long$RowNames[index] == lettre_base]] <- 3
    }
  
}}
  


my_palette <- colorRampPalette(c("grey", "red", "green", "blue", "purple"))(n = 5)

legend_labels <- c("Non_Impactful", "Impactful", "Pathogenic", "Patogenic Deletion", "Pathogenic and Impactful","WT")

a_plot = ggplot(data_long, aes(x = ColumnNames, y = RowNames, fill = as.factor(Value))) +
  geom_tile() +
  scale_fill_manual(values = my_palette, labels = legend_labels)+
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1) 
  ) +
  labs(x = "Index", y = "Acide Aminés", fill = "Valeur") +
  guides(fill = guide_legend(title = "Valeur")) +
  scale_x_discrete()  


trace_data <- as.data.frame(t(Conservation["trace",]))
trace_data$Index <- colnames(Conservation)
colnames(trace_data) <- c("Value", "Index")
df_trace <- trace_data
# Transformation des valeurs dans la colonne "Index" en numériques
trace_data$Index <- as.numeric(gsub("X", "", trace_data$Index))


b_plot <- ggplot(trace_data, aes(x = Index, y = Value)) +
  geom_bar(data = trace_data %>% filter(Index %in% regions_indices), aes(x = Index, y = Value, fill = "Région particulière"), stat = "identity") +
  geom_bar(data = trace_data %>% filter(!Index %in% regions_indices), aes(x = Index, y = Value, fill = "Autre région"), stat = "identity") +
  labs(title = "Trace par position sur la protéine", x = "Index", y = "Trace") +
  scale_fill_manual(values = c("Région particulière" = "green"), labels = "Région particulière", name = "")


combined_plot <- histogram + a_plot + b_plot + plot_layout(nrow = 3, heights = c(1,3, 1))


print(combined_plot)


```

#### Sequences chosen

```{r Zoom,  message=FALSE,fig.width=10,fig.height=10,warning=FALSE}


intervalle = INTERVALLE

print(intervalle)

histogram <- histogram +
  xlim(intervalle)
a_plot <- a_plot +
  xlim(intervalle)
b_plot <- b_plot +
  xlim(intervalle)
combined_plot <- histogram + a_plot + b_plot + plot_layout(nrow = 3, heights = c(1, 3, 1))


print(combined_plot)


```

### 2/ Alignments {.tabset .tabset-fade}

Here, we disregard the threshold, and instead, we have a gradient of red indicating the GEMME score (the lower the value, the more deleterious the amino acid), and another color gradient in blue representing the same values but for pathogenic amino acids (according to Bichat Hospital's data). In yellow, we highlight the WT amino acids that are pathogenic in case of deletion, and in gray, the non-pathogenic WT amino acids.

The black dots (MSA) indicate the multiple sequence alignments found for each exon (for the human WT sequence). Each column can have a maximum of 10 different points, as these alignments are performed with 10 different species.

The two histograms are the same as in part 1.

#### General view of the protein

```{r heatmaps_2,  message=FALSE,fig.width=10,fig.height=10,warning=FALSE}

### Hist ####################################################################

EvolCombi_matrix <- as.matrix(EvolCombi)

for (col in 1:ncol(EvolCombi_matrix)) {
  col_mean <- mean(EvolCombi_matrix[, col], na.rm = TRUE)  
  EvolCombi_matrix[is.na(EvolCombi_matrix[, col]), col] <- col_mean
}

col_means_Combi <- colMeans(EvolCombi_matrix)


mean_data <- data.frame(Index = 1:length(col_means_Combi), Mean = col_means_Combi)

histogram <- ggplot(mean_data, aes(x = Index, y = Mean)) +
  geom_bar(stat = "identity", fill = "blue") +
  labs(title = "Histogramme des Moyennes EvolCombi par colonne", x = "Index a.a", y = "Moyenne EvolCombi") 

###############################################################################
data <- EvolCombi
data_df <- as.data.frame(data)
data_df$RowNames <- rownames(data_df)  
data_long <- reshape2::melt(data_df, id.vars = "RowNames")
colnames(data_long) <- c("RowNames", "ColumnNames", "Value")
data_long$ColumnNames <- as.numeric(data_long$ColumnNames)
data_long <- data_long %>%
  mutate(Key = 0)


### Région particulière 
matrice1 <- FBN1_structure[[1]]
indices_lignes_non_na <- !is.na(matrice1$`Régions particulières`)
noms_de_lignes <- matrice1$`Régions particulières`[indices_lignes_non_na]
numeros_de_lignes <- matrice1$`n°aa`[indices_lignes_non_na]
régions <- data.frame(NomDeLigne = noms_de_lignes, NumeroDeLigne = numeros_de_lignes)
regions_indices <- which(!is.na(matrice1$`Régions particulières`))


if (mutation_pathogene == "patho"){
for (i in 1:nrow(mutation)) {
  # Récupérer la position, la lettre de base et la lettre substituée
  position <- mutation$Position[i]
  lettre_base <- mutation$AA_de_base[i]
  lettre_substituee <- mutation$AA_substitue[i]
  
  # Trouver l'indice correspondant dans data_long
  index <- which(data_long$ColumnNames == position)
  
   if (!is.na(lettre_substituee)) {
      data_long$Key[index[data_long$RowNames[index] == lettre_substituee]] <- 1
   }  else {data_long$Key[index[data_long$RowNames[index] == lettre_base]] <- 2
   } } } 



if (mutation_pathogene == "div") {
for (i in 1:nrow(mutation_probable)) {
  # Récupérer la position, la lettre de base et la lettre substituée
  position <- mutation_probable$Position[i]
  lettre_base <- mutation_probable$AA_de_base[i]
  lettre_substituee <- mutation_probable$AA_substitue[i]
  
  # Trouver l'indice correspondant dans data_long
  index <- which(data_long$ColumnNames == position)
  
   if (!is.na(lettre_substituee)) {
      data_long$Key[index[data_long$RowNames[index] == lettre_substituee]] <- 1
   }  else {data_long$Key[index[data_long$RowNames[index] == lettre_base]] <- 2
   } }}



if (mutation_pathogene == "non") {
for (i in 1:nrow(mutation_non_sens)) {
  # Récupérer la position, la lettre de base et la lettre substituée
  position <- mutation_non_sens$Position[i]
  lettre_base <- mutation_non_sens$AA_de_base[i]
  lettre_substituee <- mutation_non_sens$AA_substitue[i]
  
  # Trouver l'indice correspondant dans data_long
  index <- which(data_long$ColumnNames == position)
  
   if (!is.na(lettre_substituee)) {
      data_long$Key[index[data_long$RowNames[index] == lettre_substituee]] <- 1
   }  else {data_long$Key[index[data_long$RowNames[index] == lettre_base]] <- 2
   } }}



data_long <- data_long %>%
  mutate(Key = ifelse(is.na(Value) & Key != 2, 3, Key))



data_long0 <- data_long %>%
  filter(Key == 0) %>%
  select(-Key)

##Patch pour bug des heatmaps 
data_long0 <- data_long %>%
  mutate(Value = ifelse(Key == 1, Value - 20, Value))
#######
data_long1 <- data_long %>%
  filter(Key == 1) %>%
  select(-Key)

data_long2 <- data_long %>%
  filter(Key == 2) %>%
  select(-Key)

data_long3 <- data_long %>%
  filter(Key == 3) %>%
  select(-Key)



data_long4 <- data_longMSA %>%
  filter(Value != 0)  %>% mutate(Value = NA)

data_long1$Value <- as.numeric(data_long1$Value)
write.csv(data_long1, file = "mutations.csv", row.names = TRUE)



colors <- c("#4B0000", "#F08080", "#008000", "#FFFFFF")


a_plot <- ggplot(data_long0, aes(ColumnNames, RowNames)) +
  labs(x = "Index", y = "Acide Aminés") +
  geom_tile(aes(fill = Value)) +
scale_fill_gradientn(colors = colors, values = scales::rescale(c(-20, -6, 0, 10)), name = "selection pressure") +
  new_scale_fill() +
 #  geom_tile(data = data_long1, aes(x = ColumnNames, y = RowNames, fill = Value)) +
 # scale_fill_gradientn(colors = rev(brewer.pal(9, "Blues")), name = "Pathogenic")+
 #  guides(fill = guide_legend(title = "Pathogenic")) +
 #  new_scale_fill() +
  geom_tile(data = data_long2, aes(fill = "WT deleted is pathogenic")) +
  scale_fill_manual(values = "yellow", name = "Deletion") +
  new_scale_fill() +
  geom_tile(data = data_long3, aes(fill = "WT")) +
  scale_fill_manual(values = "gray", name = "WT") +
  new_scale_fill() +
  geom_point(data = data_long4, aes(x = ColumnNames, y = RowNames), shape = 19, size = 0.4, color = "black", name = "MSA") +
  geom_tile(data = data_long4, aes(fill = "MSA")) +
  scale_fill_manual(values = "transparent", name = "MSA") 

  

trace_data <- as.data.frame(t(Conservation["trace",]))
trace_data$Index <- colnames(Conservation)
colnames(trace_data) <- c("Value", "Index")
df_trace <- trace_data



###### Hist régions particulière
# Transformation des valeurs dans la colonne "Index" en numériques
trace_data$Index <- as.numeric(gsub("X", "", trace_data$Index))


b_plot <- ggplot(trace_data, aes(x = Index, y = Value)) +
  geom_bar(data = trace_data %>% filter(Index %in% regions_indices), aes(x = Index, y = Value, fill = "Région particulière"), stat = "identity") +
  geom_bar(data = trace_data %>% filter(!Index %in% regions_indices), aes(x = Index, y = Value, fill = "Autre région"), stat = "identity") +
  labs(title = "Trace par position sur la protéine", x = "Index", y = "Trace") +
  scale_fill_manual(values = c("Région particulière" = "green"), labels = "Région particulière", name = "")

combined_plot <- histogram + a_plot + b_plot + plot_layout(nrow = 3, heights = c(1,3,1))


print(combined_plot)




```

#### Domaine TB5

```{r Zoom_3,  message=FALSE,fig.width=10,fig.height=10,warning=FALSE}


intervalle = c(1685,1770)

print(intervalle)

histogram <- histogram +
  xlim(intervalle)
a_plot <- a_plot +
  xlim(intervalle)
b_plot <- b_plot +
  xlim(intervalle)
combined_plot <- histogram + a_plot + b_plot + plot_layout(nrow = 3, heights = c(1, 3, 1))


print(combined_plot)



```

#### Région néonatale

```{r Zoom_2,  message=FALSE,fig.width=10,fig.height=10,warning=FALSE}


intervalle = c(930,1380)

print(intervalle)

histogram <- histogram +
  xlim(intervalle)
a_plot <- a_plot +
  xlim(intervalle)
b_plot <- b_plot +
  xlim(intervalle)
combined_plot <- histogram + a_plot + b_plot + plot_layout(nrow = 3, heights = c(1, 3, 1))


print(combined_plot)


cat("mutation sur 1070") 

intervalle = c(1060,1080)

print(intervalle)

histogram <- histogram +
  xlim(intervalle)
a_plot <- a_plot +
  xlim(intervalle)
b_plot <- b_plot +
  xlim(intervalle)
combined_plot <- histogram + a_plot + b_plot + plot_layout(nrow = 3, heights = c(1, 3, 1))


print(combined_plot)


cat("mutation sur 1748") 
intervalle = c(1740,1755)

print(intervalle)

histogram <- histogram +
  xlim(intervalle)
a_plot <- a_plot +
  xlim(intervalle)
b_plot <- b_plot +
  xlim(intervalle)
combined_plot <- histogram + a_plot + b_plot + plot_layout(nrow = 3, heights = c(1, 3, 1))


print(combined_plot)



```
#### Table of pathogenis mutations 
```{r Table,  message=FALSE,fig.width=10,fig.height=10,warning=FALSE}



cat("Ici se trouve la table ou les mutations pathogènes sont enregistré (variance de bleus) afin de vérifier les erreurs du plot")
print(kable(data_long1))
```
## Scatter plot mutations


```{r mutations,  warning=FALSE, message=FALSE}


colnames(mean_data)[colnames(mean_data) == "Index"] <- "Position"
if (mutation_pathogene == "patho") {merged_data <- merge(mutation, mean_data, by = "Position")
mutations_mean_gemme <- merged_data[!is.na(merged_data$AA_substitue), c("AA_substitue", "Position", "Mean")]} 
if (mutation_pathogene == "div") {merged_data <- merge(mutation_probable, mean_data, by = "Position")
mutations_mean_gemme <- merged_data[!is.na(merged_data$AA_substitue), c("AA_substitue", "Position", "Mean","classe")]}
if (mutation_pathogene == "non") {merged_data <- merge(mutation_non_sens, mean_data, by = "Position")
mutations_mean_gemme <- merged_data[!is.na(merged_data$AA_substitue), c("AA_substitue", "Position", "Mean","Clinique","Néomutation.","Cardio","Ophtalmo","Pneumothorax","cutané","neuro","Sévère.ou.jeune")]}


melted_matrix <- rownames_to_column(EvolCombi, var = "AA_substitue")
melted_matrix <- melt(melted_matrix, id.vars = c("AA_substitue"), value.name = "EvolCombi") %>%
  mutate(Position = as.numeric(gsub("V", "", variable))) %>%
  select(AA_substitue, Position, EvolCombi)
merged_data_final <- merge(mutations_mean_gemme, melted_matrix, by = c("Position", "AA_substitue"))
scatter_plot_final <- ggplot(merged_data_final, aes(x = Mean, y = EvolCombi)) +
  geom_point()   +
  geom_text(aes(label = Position), hjust = 1, vjust = 1) +
  labs(x = "Mean GEMME", y = "GEMME Score for mutation") +
  ggtitle("Scatter Plot for Marfan mutations and GEMME score") + 
  coord_fixed(ratio = 1) 

print(scatter_plot_final)
if (mutation_pathogene == "non") {
  # Liste des colonnes à exclure lors de la création des scatter plots
  exclude_cols <- c("Position", "AA_substitue", "Mean", "EvolCombi","Clinique","Néomutation.")
  
  # Parcourir toutes les colonnes sauf celles à exclure
  for (col in setdiff(names(merged_data_final), exclude_cols)) {
    # Création du scatter plot pour chaque colonne
    scatter_plot <- ggplot(merged_data_final, aes_string(x = "Mean", y = "EvolCombi", color = col)) +
      geom_point() +
      labs(x = "Mean GEMME", y = "GEMME Score for mutation") +
      ggtitle(paste("Scatter Plot for Marfan mutations and GEMME score (", col, ")", sep = "")) + 
      coord_fixed(ratio = 1)
    # Sauvegarde du scatter plot dans un fichier
    ggsave(paste("Mutation_plot/", col, "_scatter_plot.png", sep = ""), plot = scatter_plot)
  }
}

if (mutation_pathogene == "div") {
scatter_plot_final <- ggplot(merged_data_final, aes(x = Mean, y = EvolCombi, color = classe)) +
  geom_point() +
  labs(x = "Mean GEMME", y = "GEMME Score for mutation") +
  ggtitle("Scatter Plot for Marfan mutations and GEMME score") + 
  coord_fixed(ratio = 1)
}


print(scatter_plot_final)

  
# Calculer les moyennes par position
mean_by_position <- aggregate(EvolCombi ~ Position, melted_matrix, mean)

# Ajouter la colonne Mean à melted_matrix
melted_matrix <- merge(melted_matrix, mean_by_position, by = "Position", suffixes = c("", ".Mean"))

# Créez la colonne InMutationsMeanGemme en fonction de la présence dans mutations_mean_gemme
melted_matrix$InMutationsMeanGemme <- ifelse(
  melted_matrix$AA_substitue == mutations_mean_gemme$AA_substitue & melted_matrix$Position == mutations_mean_gemme$Position,
  "Pathogenic",
  "Not Pathogenic"
)

# Réglage des échelles égales sur l'axe x et y
scatter_plot_final <- ggplot(melted_matrix, aes(x = EvolCombi.Mean, y = EvolCombi, color = InMutationsMeanGemme)) +
  geom_point(alpha = 0.01, size = 2, color = "blue") +
  geom_point(data = merged_data_final, aes(x = Mean, y = EvolCombi), color = "red", size = 2) +
  labs(x = "Mean GEMME", y = "GEMME Score for mutation") +
  ggtitle("Scatter Plot for Marfan mutations and GEMME score") +
  coord_fixed(ratio = 1)  +
  geom_vline(xintercept = mean(range(melted_matrix$EvolCombi.Mean)), linetype = "dashed", color = "gray") 
# Afficher le scatter plot
print(scatter_plot_final)




```

## Repeats cb EGF like {.tabset .tabset-fade}

Description in each tab: In "Pairwise," we depict the correspondence of repeats one by one; each point represents an amino acid locus with the GEMME score (selection pressure) indicating whether the amino acid from one sequence is found in the sequence of the other and vice versa. In the heatmap tab, we provide heatmaps of mutations followed by the heatmap comparing repeats based on the GEMME score.
### Pairewise

```{r repeats,  warning=FALSE, message=FALSE}
# Charger les séquences alignées
aligned_sequences <- readAAStringSet("aligned_sequences.fasta")

# Sélectionner les structures EGF-like
selected_structures <- subset(Table_seq, grepl("^cb EGF-like ", Structure))

final_result_list <- list()
# Boucle à travers chaque paire de séquences
for (i in 1:(length(aligned_sequences))) {
    R1_sequence <- aligned_sequences[i]
    R1_name <- names(aligned_sequences)[i]
    results_list <- list()
    cat("R1:", R1_name, "\n")
   for (j in 1:length(aligned_sequences)) {
    if (j != i)  {
    # Extraire les informations pour la paire de séquences actuelle

    R2_sequence <- aligned_sequences[j]
    R2_name <- names(aligned_sequences)[j]
 cat("R2:", R2_name, "\n")
get_debut_for_name <- function(sequence_name, structures_table) {
  match_index <- grep(sequence_name, structures_table$Structure)
    if (length(match_index) > 0) {
    debut_fin_value <- structures_table$Debut_Fin[match_index]
        debut_value <- sub(";.*", "", debut_fin_value)
    
    return(debut_value)
  } else {
    return(NA)
  }
}


# Utile en avale du code 
get_end_for_name <- function(sequence_name, structures_table) {
  match_index <- grep(sequence_name, structures_table$Structure)
  
  if (length(match_index) > 0) {
    debut_fin_value <- structures_table$Debut_Fin[match_index]
    end_value <- sub(".*;", "", debut_fin_value)
    
    return(end_value)
  } else {
    return(NA)
  }
}
####


create_sequence_table <- function(sequence, debut_value) {
  sequence_table <- data.frame(
    Caractere = unlist(strsplit(as.character(sequence), "")),
    Position_Absolue = debut_value + seq_along(sequence) - 1
  )
  
  # Ajouter le décalage uniquement pour les acides aminés (et laisser NA pour les gaps)
  sequence_table$Position_Absolue <- ifelse(sequence_table$Caractere != "-", 
                                           sequence_table$Position_Absolue, NA)
  
  # Ajouter +1 aux lignes suivantes (sauf si "-")
  sequence_table$Position_Absolue[!is.na(sequence_table$Position_Absolue)] <- 
    sequence_table$Position_Absolue[!is.na(sequence_table$Position_Absolue)] +
    seq_along(sequence_table$Position_Absolue[!is.na(sequence_table$Position_Absolue)]) - 1
  rownames(sequence_table) = NULL
  return(sequence_table)
}


debut_R1 <- as.integer(get_debut_for_name(R1_name, selected_structures))
debut_R2 <- as.integer(get_debut_for_name(R2_name, selected_structures))

table_R1 <- create_sequence_table(R1_sequence, debut_R1)
table_R2 <- create_sequence_table(R2_sequence, debut_R2)

table_R1$Caractere <- tolower(table_R1$Caractere)
table_R2$Caractere <- tolower(table_R2$Caractere)

combined_R1_R2  = cbind(table_R1, table_R2)
colnames(combined_R1_R2) <- c(paste(names(table_R1), "R1", sep = "_"), paste(names(table_R2), "R2", sep = "_"))


# Joindre combined_R1_R2 avec melted_matrix sur la première condition (left join) sans trier
result1 <- merge(combined_R1_R2, melted_matrix, by.x = c("Caractere_R1", "Position_Absolue_R2"), by.y = c("AA_substitue", "Position"), all.x = TRUE, sort = FALSE)

# Joindre combined_R1_R2 avec melted_matrix sur la deuxième condition (left join) sans trier
result2 <- merge(combined_R1_R2, melted_matrix, by.x = c("Caractere_R2", "Position_Absolue_R1"), by.y = c("AA_substitue", "Position"), all.x = TRUE, sort = FALSE)
colnames(result1)[colnames(result1) == "EvolCombi"] <- "AA de R1 score dans R2"
colnames(result2)[colnames(result2) == "EvolCombi"] <- "AA de R2 score dans R1"

# Enlève les gaps de R1 
result1 <- subset(result1, !is.na(Position_Absolue_R1))
result2 <- subset(result2, !is.na(Position_Absolue_R1))


# Étape 1 : Supprimer les colonnes
result1 <- result1[, !(names(result1) %in% c("EvolCombi.Mean", "InMutationsMeanGemme"))]
result2 <- result2[, !(names(result2) %in% c("EvolCombi.Mean", "InMutationsMeanGemme"))]

# Étape 2 : Trier les résultats en tenant compte des valeurs "NA"
result1 <- result1[order(result1$Position_Absolue_R1, result1$Position_Absolue_R2), ]
result2 <- result2[order(result2$Position_Absolue_R1, result2$Position_Absolue_R2), ]



count_non_na_r1 <- sum(!is.na(result1$Position_Absolue_R1))
count_non_na_r2 <- sum(!is.na(result2$Position_Absolue_R2))


if (count_non_na_r1 == count_non_na_r2) {

  merged_results <- cbind(result1, result2[,-1]) 
} else {

  if (count_non_na_r1 > count_non_na_r2) {
    result1 <- result1[order(result1$Position_Absolue_R1), ]
    result2 <- result2[order(result2$Position_Absolue_R1), ]
  } else {
    result1 <- result1[order(result1$Position_Absolue_R2), ]
    result2 <- result2[order(result2$Position_Absolue_R2), ]
  }
  
  # Fusionner les résultats
  merged_results <- cbind(result1, result2[,-1]) 
}


combined_R1_R2 <- merged_results

combined_R1_R2 <- combined_R1_R2 %>% 
  select(unique(colnames(.)))

results_list[[R2_name]] <- combined_R1_R2

scatter_plot <- ggplot(combined_R1_R2, aes(x = `AA de R1 score dans R2`, y = `AA de R2 score dans R1`)) +
  geom_point() +
  labs(x = "AA de R1 score dans R2", y = "AA de R2 score dans R1", title = "Scatter Plot") +
  theme_minimal()

print(scatter_plot)

    } }
    
    
        final_result_list[[R1_name]] <- results_list



     
     }

```


### Heatmaps
```{r repeats_heatmaps,  warning=FALSE, message=FALSE,fig.width=15,fig.height=15}

add_suffix <- function(names) {
  seen <- c()
  result <- character(length(names))
  for (i in seq_along(names)) {
    if (names[i] %in% seen) {
      suffix <- sum(seen == names[i])
      result[i] <- paste(names[i], suffix, sep = ".")
    } else {
      result[i] <- names[i]
    }
    seen <- c(seen, names[i])
  }
  return(result)
}


ajouter_suffixe_colonnes <- function(heatmap_data, chiffres) {
  # Vérification de la longueur
  # Modifier les noms des colonnes
  for (i in 1:length(chiffres)) { 
    colnames(heatmap_data)[i] <- paste(colnames(heatmap_data)[i], chiffres[i], sep = "$")
  }
  
  return(heatmap_data)
}


# Boucle à travers chaque élément R1 de final_result_list
for (R1_name in names(final_result_list)) {
    print(R1_name)
    results_list <- final_result_list[[R1_name]]
    
    if (R1_name == "cb EGF-like #02"){
        NCOL =  dim(final_result_list[[R1_name]]$`cb EGF-like #01`)[1]
    } else {
        NCOL =  dim(final_result_list[[R1_name]]$`cb EGF-like #02`)[1]
    }
    heatmap_data <- matrix(nrow = 42, ncol = NCOL)

    row_names_except_current <- setdiff(names(final_result_list), R1_name)
    
    if (R1_name == "cb EGF-like #02"){
        colnames(heatmap_data) <- final_result_list[[R1_name]]$`cb EGF-like #01`$Caractere_R1
        locus <- final_result_list[[R1_name]]$`cb EGF-like #01`$Position_Absolue_R1
    } else {
       colnames(heatmap_data) <- final_result_list[[R1_name]]$`cb EGF-like #02`$Caractere_R1
       locus <- final_result_list[[R1_name]]$`cb EGF-like #02`$Position_Absolue_R1
    }
    
    new_colnames <- add_suffix(colnames(heatmap_data))
    rownames(heatmap_data) <- row_names_except_current
    
    colnames(heatmap_data) = locus
    for (R2_name in row_names_except_current) {
        # Récupérer les scores depuis final_result_list
        scores <- final_result_list[[R1_name]][[R2_name]]$`AA de R1 score dans R2`
        
        # Trouver l'index de la ligne correspondant au R2_name dans la matrice
        row_index <- match(R2_name, row_names_except_current)
        
        # Assigner les scores à la ligne appropriée dans la matrice
        heatmap_data[row_index, ] <- scores
      
    }
    
    heatmap_data_long <- melt(heatmap_data)


# Supposons que 'mutations_non_sens$Position' est un vecteur d'indices à marquer
indices_a_marquer <- mutation_non_sens$Position

# Ajouter une colonne pour vérifier si l'indice est dans 'indices_a_marquer'
heatmap_data_long$is_index_to_mark <- ifelse(heatmap_data_long$Var2 %in% indices_a_marquer, TRUE, FALSE)

#Permet d'avoir les acides aminés 
colnames(heatmap_data) = new_colnames
heatmap_data_long2 = melt(heatmap_data)
heatmap_data_long$Var2 = heatmap_data_long2$Var2



d_plot <- ggplot(heatmap_data_long, aes(Var2, Var1)) +
  labs(x = R1_name, y = "Repeats") + 
  geom_tile(aes(fill = value)) +
  scale_fill_gradient2(low = "red", mid = "yellow", high = "white",
                       midpoint = -3, name = "selection pressure") +
  # Personnalisation des légendes
  scale_color_manual(values = "blue", guide = FALSE) +
  guides(fill = guide_legend(title = "selection pressure")) +
  # Ajouter une couche pour marquer les colonnes
  geom_segment(data = subset(heatmap_data_long, is_index_to_mark == TRUE),
               aes(x = Var2, xend = Var2, y = Var1 - 0.5, yend = Var1 + 0.5), color = "black", size = 1) + 
  geom_point(data = subset(heatmap_data_long, is_index_to_mark == TRUE),
             aes(x = Var2, y = Var1), color = "black", size = 3) 


print(d_plot)

 }



    
```


```{r signature_logo,  warning=FALSE, message=FALSE,fig.width=15,fig.height=15}
   




 
```
